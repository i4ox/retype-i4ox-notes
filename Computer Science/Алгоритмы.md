# Алгоритмы

## Что такое алгоритм?

**Алгоритм** - набор инсрукций для выполнения некоторой задачи. Хотя, в принципе, любой фрагмент кода можно считать алгоритмом.

## Что такое О-большое?

Специальная нотация "О-большое" описывает скорость работы алгоритма.

Предположим, у нас ограничение в 100мс и надо проверить 100 элементов - Пусть 1мс это тоже самое что и 1 операция.

Для простого алгоритма можно считать это скоростью О(100), то есть 100мс.

А в случае с бинарным поиском это скорость О(log100), то есть 7мс.

1. 2^6 = 64
2. 2^7 = 128
3. 64 < 100 < 128

Можно сказать, что О(`количество операций`), то есть это обозначение того сколько операций понадобится в _худшем случае_.

### Типичные варинты О-большого

- О(log n) - **_логарифмическое время_**. Пример: бинарный поиск.
- О(n) - **_линейное время_**. Пример: простой поиск(тупой поиск).
- О(n \* log n) - **_логарифмическое время_**. Пример: эффективные алгоритмы сортировки.
- О(n^2) - **_квадратичное время_**. Пример: медленные алгоритмы сортировки.
- О(n!) - **_факторическое время_**. Пример: очень медленные алгоритмы сортировки.

| Количество элементов | О(log n) | О(n)   | О(n \* log n) | О(n^2)  | О(n!)              |
| -------------------- | -------- | ------ | ------------- | ------- | ------------------ |
| 16                   | 0.4c     | 1.6c   | 6.4c          | 25.6c   | 66301 лет          |
| 256                  | 0.8c     | 25.6c  | 3.4мин        | 1.8ч    | 8.6 \* 10^505 лет  |
| 1024                 | 1.0c     | 1.7мин | 17мин         | 1.2 дня | 5.4 \* 10^2438 лет |

## Бинарный поиск

**Бинарный поиск** - алгоритм; на входе получает отсортированный список элементов.
Если элемент, который вы ищете, присутствует в списке, то алгоритмы возвращает ту позицию, где он находится, в противном случае возвращает тип данных `nil`.

### Когда использовать бинарный поиск?

Предположим, вы ищете фамилию человека в списке людей.
Она начинается с буквы K.
Конечно, можно начать с самого начала списка, но это занимает больше времени.
Так что для ускорения поиска его можно начинать с середины списка.
Ведь буква K должна находиться ближе к середине списка.

### Как работает бинарный поиск?

Рассмотрим следующий пример: я загадал число от 1 до 100.
Вы должны отгадать мое число, использовав меньшее количество поисковых шагов.
И при каждом ответе я буду говорить один из трех ответов: _мало_, _много_ или _угадал_.

### Почему он лучше чем тупой поиск?

Предположим, что у нас есть массив из 240 тысяч чисел.

Наихудший случай для тупого поиска будет _239999_ попыток.

А вот для бинарного поиска всего лишь _18_ попыток, потому что всегда отсекается половина списка.

```sh
240k -> 120k -> 60k -> 30k -> 15k -> 7.5k -> 3750 -> 1875 -> 938 -> 469 -> 235 -> 118 -> 59 -> 30 -> 15 -> 8 -> 4 -> 2 -> 1
```

### Сложность алгоритма

В общем случае для списка из n элементов алгоритм будет работать в O(log n) шагов. В то время как тупой поиск будет работать в O(n) шагов.

### Реализация бинарного поиска на Go

```go
func binarySearch(list []int, target int) int {
	left, right := 0, len(list)-1
	for left <= right {
		mid := (left + right) / 2
		if list[mid] == target {
			return mid
		} else if list[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}
```

## Сортировка выбором

**Сортировка выбором** – это алгоритм сортировки, который работает, находя наименьший элемент в списке и перемещая его в начало.
Затем он находит следующий наименьший элемент и перемещает его на вторую позицию, и так далее, пока список не будет отсортирован.

### Когда использовать сортировку выбором?

Если у тебя небольшой список и важна простота реализации, этот метод подойдет. Однако для больших массивов он неэффективен.

### Как работает сортировка выбором?

Рассмотрим следующий список чисел: `[29, 10, 14, 37, 13]`.

1. Находим наименьший элемент в списке и перемещаем его в начало списка. -> 10 -> `[10, 29, 14, 37, 13]`.
2. Находим следующий наименьший элемент и перемещаем его на вторую позицию. -> 13 -> `[10, 13, 14, 37, 29]`.
3. Находим следующий наименьший элемент и перемещаем его на третью позицию. -> 14 -> `[10, 13, 14, 37, 29]`.
4. Находим следующий наименьший элемент и перемещаем его на четвертую позицию. -> 29 -> `[10, 13, 14, 29, 37]`.

### Сложность алгоритма

Сложность алгоритма сортировки выбором равна `O(n^2)`.

### Реализация сортировки выбором на Go

```go
func selectionSort(list []int) {
	for i := 0; i < len(list); i++ {
		min := i
		for j := i + 1; j < len(list); j++ {
			if list[j] < list[min] {
				min = j
			}
		}
		list[i], list[min] = list[min], list[i]
	}
}
```

## Рекурсия

**Рекурсия** - элегантный способ решения задач. Это метод решения задач, при котором функция вызывает саму себя в процессе выполнения.

Рекурсивные алгоритмы широко используются в программировании для решения задач, которые можно разбить на более простые подзадачи того же типа.

### Когда использовать рекурсию?

Рекурсия полезна, когда задача естественным образом разделяется на аналогичные, но меньшие по размеру подзадачи.

Рекурсия часто применяется:

- В деревьях.
- В графах.
- В сортировках.
- В математических вычислениях.

### Как работает рекурсия?

Рекурсивная функция обычно состоит из двух частей:

1. **Базовый случай** – условие, при котором функция прекращает вызывать саму себя и возвращает результат. Это необходимо для предотвращения бесконечной рекурсии.
2. **Рекурсивный случай** – часть функции, в которой она вызывает саму себя с измененными аргументами, приближаясь к базовому случаю.

Рассмотрим в качестве примера вычисления факториала числа.

Факториал числа для n обозначается как n! и выглядит как произведение чисел от 1 до n.

Рекурсивное определение факториала для n можно представить следующим образом:

- Базовый случай: 0! = 1 или 1! = 1.
- Рекурсивный случай: n! = n \* (n-1)!

Преимущества:

- Упрощает код для задач, которые естественно рекурсивны.
- Позволяет легко реализовывать сложные алгоритмы.

Недостатки:

- Может привести к большому количеству вызовов функции, что увеличивает расход памяти.
- Риск переполнения стека.
- Менее эффективна в сравнении с итеративными алгоритмами из-за накладных расходов памяти

### Сложность алгоритма

Сложность рекурсивных алгоритмов зависит от количества рекурсивных вызовов и работы, выполняемой на каждом шаге.
Например, для вычисления факториала сложность будет `O(n)`, то есть один раз на каждый шаг производится вычисление n-1-й части факториала.

### Реализация рекурсии на Go

```go
func factorial(n int) int {
	if n == 0 {
		return 1
	}
	return n * factorial(n-1)
}

func fibonacci(n int) int {
	if n == 0 {
		return 0
	} else if n == 1 {
		return 1
	}
	return fibonacci(n-1) + fibonacci(n-2)
}
```
