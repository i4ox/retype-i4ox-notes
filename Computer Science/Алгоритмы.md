# Алгоритмы

## Что такое алгоритм?

**Алгоритм** - набор инсрукций для выполнения некоторой задачи. Хотя, в принципе, любой фрагмент кода можно считать алгоритмом.

## Что такое О-большое?

Специальная нотация "О-большое" описывает скорость работы алгоритма.

Предположим, у нас ограничение в 100мс и надо проверить 100 элементов - Пусть 1мс это тоже самое что и 1 операция.

Для простого алгоритма можно считать это скоростью `O(100)`, то есть 100мс.

А в случае с бинарным поиском это скорость `О(log100)`, то есть 7мс.

1. 2^6 = 64
2. 2^7 = 128
3. 64 < 100 < 128

Можно сказать, что О(`количество операций`), то есть это обозначение того сколько операций понадобится в _худшем случае_.

### Типичные варинты О-большого

- О(log n) - **_логарифмическое время_**. Пример: бинарный поиск.
- О(n) - **_линейное время_**. Пример: простой поиск(тупой поиск).
- О(n \* log n) - **_логарифмическое время_**. Пример: эффективные алгоритмы сортировки.
- О(n^2) - **_квадратичное время_**. Пример: медленные алгоритмы сортировки.
- О(n!) - **_факторическое время_**. Пример: очень медленные алгоритмы сортировки.

| Количество элементов | О(log n) | О(n)   | О(n \* log n) | О(n^2)  | О(n!)              |
| -------------------- | -------- | ------ | ------------- | ------- | ------------------ |
| 16                   | 0.4c     | 1.6c   | 6.4c          | 25.6c   | 66301 лет          |
| 256                  | 0.8c     | 25.6c  | 3.4мин        | 1.8ч    | 8.6 \* 10^505 лет  |
| 1024                 | 1.0c     | 1.7мин | 17мин         | 1.2 дня | 5.4 \* 10^2438 лет |

## Бинарный поиск

**Бинарный поиск** - алгоритм; на входе получает отсортированный список элементов.
Если элемент, который вы ищете, присутствует в списке, то алгоритмы возвращает ту позицию, где он находится, в противном случае возвращает тип данных `nil`.

### Когда использовать бинарный поиск?

Предположим, вы ищете фамилию человека в списке людей.
Она начинается с буквы K.
Конечно, можно начать с самого начала списка, но это занимает больше времени.
Так что для ускорения поиска его можно начинать с середины списка.
Ведь буква K должна находиться ближе к середине списка.

### Как работает бинарный поиск?

Рассмотрим следующий пример: я загадал число от 1 до 100.
Вы должны отгадать мое число, использовав меньшее количество поисковых шагов.
И при каждом ответе я буду говорить один из трех ответов: _мало_, _много_ или _угадал_.

### Почему он лучше чем тупой поиск?

Предположим, что у нас есть массив из 240 тысяч чисел.

Наихудший случай для тупого поиска будет _239999_ попыток.

А вот для бинарного поиска всего лишь _18_ попыток, потому что всегда отсекается половина списка.

```sh
240k -> 120k -> 60k -> 30k -> 15k -> 7.5k -> 3750 -> 1875 -> 938 -> 469 -> 235 -> 118 -> 59 -> 30 -> 15 -> 8 -> 4 -> 2 -> 1
```

### Сложность алгоритма

В общем случае для списка из n элементов алгоритм будет работать в `O(log n)` шагов. В то время как тупой поиск будет работать в `O(n)` шагов.

### Реализация бинарного поиска на Go

```go
func binarySearch(list []int, target int) int {
	left, right := 0, len(list)-1
	for left <= right {
		mid := (left + right) / 2
		if list[mid] == target {
			return mid
		} else if list[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}
```

## Рекурсия (Recursion)

**Рекурсия** - элегантный способ решения задач. Это метод решения задач, при котором функция вызывает саму себя в процессе выполнения.

Рекурсивные алгоритмы широко используются в программировании для решения задач, которые можно разбить на более простые подзадачи того же типа.

### Когда использовать рекурсию?

Рекурсия полезна, когда задача естественным образом разделяется на аналогичные, но меньшие по размеру подзадачи.

Рекурсия часто применяется:

- В деревьях.
- В графах.
- В сортировках.
- В математических вычислениях.

### Как работает рекурсия?

Рекурсивная функция обычно состоит из двух частей:

1. **Базовый случай** – условие, при котором функция прекращает вызывать саму себя и возвращает результат. Это необходимо для предотвращения бесконечной рекурсии.
2. **Рекурсивный случай** – часть функции, в которой она вызывает саму себя с измененными аргументами, приближаясь к базовому случаю.

Рассмотрим в качестве примера вычисления факториала числа.

Факториал числа для n обозначается как n! и выглядит как произведение чисел от 1 до n.

Рекурсивное определение факториала для n можно представить следующим образом:

- Базовый случай: 0! = 1 или 1! = 1.
- Рекурсивный случай: n! = n \* (n-1)!

Преимущества:

- Упрощает код для задач, которые естественно рекурсивны.
- Позволяет легко реализовывать сложные алгоритмы.

Недостатки:

- Может привести к большому количеству вызовов функции, что увеличивает расход памяти.
- Риск переполнения стека.
- Менее эффективна в сравнении с итеративными алгоритмами из-за накладных расходов памяти

### Сложность алгоритма

Сложность рекурсивных алгоритмов зависит от количества рекурсивных вызовов и работы, выполняемой на каждом шаге.
Например, для вычисления факториала сложность будет `O(n)`, то есть один раз на каждый шаг производится вычисление n-1-й части факториала.

### Реализация рекурсии на Go

```go
func factorial(n int) int {
	if n == 0 {
		return 1
	}
	return n * factorial(n-1)
}

func fibonacci(n int) int {
	if n == 0 {
		return 0
	} else if n == 1 {
		return 1
	}
	return fibonacci(n-1) + fibonacci(n-2)
}
```

### Принцип "разделяй и властвуй"

Решение задачи методом разделяй и властвуй состоит из двух частей:

1. Сначала определяется базовый случай, это должен быть простейший случай из возможных.
2. Задача делится или сокращается до тех пор, пока не придется выполнить базовый случай.

Предположим есть участок 1680 на 640 и его надо разделить на квадраты с максимальной площадью.
Мы сможем получить два квадрата площадью 640 на 640, но у нас останется еще участок 640 на 400, что не является квадратом.
Так вот к нему мы можем опять применить принцип разделяй и властвуй.

То есть алгоритм такой:

1. Площадь 1680 на 640 разделяется на квадраты с максимальной площадью, остается участок 640 на 400.
2. Площадь 640 на 400 разделяется на квадраты с максимальной площадью, остается участок 400 на 240.
3. Площадь 400 на 240 разделяется на квадраты с максимальной площадью, остается участок 240 на 160.
4. Площадь 240 на 160 разделяется на квадраты с максимальной площадью, остается участок 160 на 80.
5. Площадь 160 на 80 разделяется на квадраты с максимальной площадью. В итоге будет два квадрата с площадью 80 на 80, и лишнего участка не будет.
6. То есть базовый случай будет 160 кратно 80, а рекурсивный случай будет участок с максимальной площадью.

!!!
Стоит отдельно отметить, что скорее это не алгоритм, а подход к решению задачи.
!!!

### Пара слов о функциональном программировании

В функциональном программирование нету циклов, поэтому вместо нее используют рекурсивные функции.

Пример вычисления суммы элементов массива на Haskell:

```haskell
sum [] = 0 -- базовый случай
sum (x:xs) = x + (sum xs) -- рекурсивный случай
```

## Сортировка выбором (Selection Sort)

**Сортировка выбором** – это алгоритм сортировки, который работает, находя наименьший элемент в списке и перемещая его в начало.
Затем он находит следующий наименьший элемент и перемещает его на вторую позицию, и так далее, пока список не будет отсортирован.

### Когда использовать сортировку выбором?

Если у тебя небольшой список и важна простота реализации, этот метод подойдет. Однако для больших массивов он неэффективен.

### Как работает сортировка выбором?

Рассмотрим следующий список чисел: `[29, 10, 14, 37, 13]`.

1. Находим наименьший элемент в списке и перемещаем его в начало списка. -> 10 -> `[10, 29, 14, 37, 13]`.
2. Находим следующий наименьший элемент и перемещаем его на вторую позицию. -> 13 -> `[10, 13, 14, 37, 29]`.
3. Находим следующий наименьший элемент и перемещаем его на третью позицию. -> 14 -> `[10, 13, 14, 37, 29]`.
4. Находим следующий наименьший элемент и перемещаем его на четвертую позицию. -> 29 -> `[10, 13, 14, 29, 37]`.

### Сложность алгоритма

Сложность алгоритма сортировки выбором равна `O(n^2)`.

### Реализация сортировки выбором на Go

```go
func selectionSort(list []int) {
	for i := 0; i < len(list); i++ {
		min := i
		for j := i + 1; j < len(list); j++ {
			if list[j] < list[min] {
				min = j
			}
		}
		list[i], list[min] = list[min], list[i]
	}
}
```

## Сортировка слиянием (Merge Sort)

**Сортировка слиянием** – это алгоритм сортировки, который использует подход _«разделяй и властвуй»_.
Он разбивает список на две половины, рекурсивно сортирует каждую половину, а затем объединяет (сливает) их в один отсортированный список.

### Когда использовать сортировку слиянием?

Сортировка слиянием эффективна для больших массивов, так как её сложность всегда `O(n log n)`, независимо от начального порядка элементов.
Она также полезна, когда требуется стабильная сортировка (сохранение порядка равных элементов).

### Как работает сортировка слиянием?

Рассмотрим список чисел: `[38, 27, 43, 3, 9, 82, 10]`.

Алгоритм работает следующим образом:

1. Разделяем список на две половины: `[38, 27, 43, 3]` и `[9, 82, 10]`.
2. Рекурсивно сортируем каждую половину:
3. Левый список: `[3, 27, 38, 43]`.
4. Правый список: `[9, 10, 82]`.
5. Объединяем два отсортированных списка в один: `[3, 9, 10, 27, 38, 43, 82]`.

### Сложность алгоритма

Сложность алгоритма сортировки слиянием равна `O(n log n)`.
Также важно, что сложность алгоритма для памяти равна `O(n)`.

### Реализация сортировки слиянием на Go

```go
func merge(left, right []int) []int {
	result := make([]int, 0, len(left)+len(right))
	i, j := 0, 0
	for i < len(left) && j < len(right) {
		if left[i] < right[j] {
			result = append(result, left[i])
			i++
		} else {
			result = append(result, right[j])
			j++
		}
	}

	result = append(result, left[i:]...)
	result = append(result, right[j:]...)
	return result
}

func mergeSort(list []int) []int {
	if len(list) <= 1 {
		return list
	}
	mid := len(list) / 2
	left := mergeSort(list[:mid])
	right := mergeSort(list[mid:])
	return merge(left, right)
}
```

## Быстрая сортировка (Quick Sort)

**Быстрая сортировка** – это ещё один алгоритм, использующий подход _«разделяй и властвуй»_.
Он выбирает опорный элемент (pivot), разделяет список на две части: элементы меньше опорного и элементы больше опорного, а затем рекурсивно сортирует каждую часть.

### Когда использовать быструю сортировку?

Быстрая сортировка эффективна для больших массивов и обычно работает быстрее, чем сортировка слиянием, на практике.
Однако её производительность зависит от выбора опорного элемента. В худшем случае её сложность может достигать `O(n^2)`.

### Как работает быстрая сортировка?

Рассмотрим список чисел: `[29, 10, 14, 37, 13]`.

1. Выбираем опорный элемент, пусть будет последний элемент `13`.
2. Разделяем список на две части: `[29, 14, 37]`(больше опорного) и `[10]`(меньше опорного).
3. Рекурсивно сортируем каждую часть: `[14, 29, 37]`(больше опорного) и `[10]`(меньше опорного).
4. Объединяем результаты и опорный элемент: `[10, 13, 14, 29, 37]`.

### Сложность алгоритма

Сложность алгоритма быстрой сортировки равна `O(n log n)` в лучшем случае, а в худшем случае – `O(n^2)`.
Также важно, что сложность алгоритма для памяти равна `O(log n)` из-за рекурсии.

### Реализация быстрой сортировки на Go

```go
func quickSort(list []int) []int {
	if len(list) <= 1 {
		return list
	}
	pivot := list[len(list)-1]
	var left, right []int
	for i := 0; i < len(list)-1; i++ {
		if list[i] < pivot {
			left = append(left, list[i])
		} else {
			right = append(right, list[i])
		}
	}
	left = quickSort(left)
	right = quickSort(right)
	return append(append(left, pivot), right...)
}
```

### Сравнение алгоритмов сортировки

| Алгоритм            | Лучший случай | Средний случай | Худший случай | Память   | Когда использовать                                   |
| ------------------- | ------------- | -------------- | ------------- | -------- | ---------------------------------------------------- |
| Сортировка выбором  | O(n^2)        | O(n^2)         | O(n^2)        | O(1)     | Для небольших списков, где важна простота реализации |
| Сортировка слиянием | O(n log n)    | O(n log n)     | O(n log n)    | O(n)     | Для больших списков, где важна стабильность          |
| Быстрая сортировка  | O(n log n)    | O(n log n)     | O(n^2)        | O(log n) | Для больших списков, где важна скорость              |
