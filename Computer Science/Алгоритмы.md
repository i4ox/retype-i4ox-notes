# Алгоритмы

## Что такое алгоритм?

**Алгоритм** - набор инсрукций для выполнения некоторой задачи. Хотя, в принципе, любой фрагмент кода можно считать алгоритмом.

## Что такое О-большое?

Специальная нотация "О-большое" описывает скорость работы алгоритма.

Предположим, у нас ограничение в 100мс и надо проверить 100 элементов - Пусть 1мс это тоже самое что и 1 операция.

Для простого алгоритма можно считать это скоростью О(100), то есть 100мс.

А в случае с бинарным поиском это скорость О(log100), то есть 7мс.

1. 2^6 = 64
2. 2^7 = 128
3. 64 < 100 < 128

Можно сказать, что О(`количество операций`), то есть это обозначение того сколько операций понадобится в _худшем случае_.

### Типичные варинты О-большого

- О(log n) - **_логарифмическое время_**. Пример: бинарный поиск.
- О(n) - **_линейное время_**. Пример: простой поиск(тупой поиск).
- О(n \* log n) - **_логарифмическое время_**. Пример: эффективные алгоритмы сортировки.
- О(n^2) - **_квадратичное время_**. Пример: медленные алгоритмы сортировки.
- О(n!) - **_факторическое время_**. Пример: очень медленные алгоритмы сортировки.

| Количество элементов | О(log n) | О(n)   | О(n \* log n) | О(n^2)  | О(n!)              |
| -------------------- | -------- | ------ | ------------- | ------- | ------------------ |
| 16                   | 0.4c     | 1.6c   | 6.4c          | 25.6c   | 66301 лет          |
| 256                  | 0.8c     | 25.6c  | 3.4мин        | 1.8ч    | 8.6 \* 10^505 лет  |
| 1024                 | 1.0c     | 1.7мин | 17мин         | 1.2 дня | 5.4 \* 10^2438 лет |

## Бинарный поиск

**Бинарный поиск** - алгоритм; на входе получает отсортированный список элементов.
Если элемент, который вы ищете, присутствует в списке, то алгоритмы возвращает ту позицию, где он находится, в противном случае возвращает тип данных `nil`.

### Когда использовать бинарный поиск?

Предположим, вы ищете фамилию человека в списке людей.
Она начинается с буквы K.
Конечно, можно начать с самого начала списка, но это занимает больше времени.
Так что для ускорения поиска его можно начинать с середины списка.
Ведь буква K должна находиться ближе к середине списка.

### Как работает бинарный поиск?

Рассмотрим следующий пример: я загадал число от 1 до 100.
Вы должны отгадать мое число, использовав меньшее количество поисковых шагов.
И при каждом ответе я буду говорить один из трех ответов: _мало_, _много_ или _угадал_.

### Почему он лучше чем тупой поиск?

Предположим, что у нас есть массив из 240 тысяч чисел.

Наихудший случай для тупого поиска будет _239999_ попыток.

А вот для бинарного поиска всего лишь _18_ попыток, потому что всегда отсекается половина списка.

```sh
240k -> 120k -> 60k -> 30k -> 15k -> 7.5k -> 3750 -> 1875 -> 938 -> 469 -> 235 -> 118 -> 59 -> 30 -> 15 -> 8 -> 4 -> 2 -> 1
```

### Сложность алгоритма

В общем случае для списка из n элементов алгоритм будет работать в O(log n) шагов. В то время как тупой поиск будет работать в O(n) шагов.

### Реализация бинарного поиска на Go и TypeScript

```go
func binarySearch(list []int, target int) int {
	left, right := 0, len(list)-1
	for left <= right {
		mid := (left + right) / 2
		if list[mid] == target {
			return mid
		} else if list[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}
```

```ts
function binarySearch(list: number[], target: number): number {
  let left = 0;
  let right = list.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (list[mid] === target) {
      return mid;
    } else if (list[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}
```
