# Шпаргалка по базам данных

## Установка PSQL

```sh
docker run --name my_postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres
docker exec -it my_postgres psql -U postgres
docker start my_postgres
docker stop my_postgres
```

## Нормализация

**Нормализация** - процесс преобразования структуры БД для уменьшения избыточности данных и предотвращения аномалий обновления.
Она основана на математической теории реляционных баз данных.

### Первая нормальная форма
- У таблицы должна быть первичная ключевая колонка(ID,UUID).
- Все строки таблицы уникальны.
- Все значения атрибутов(столбцов) должны быть атомарными(неделимыми).

До 1NF:

|*Фирма*|Модели|
|-----|------|
|BMW|M5,X5M,M1|
|Nissan|GT-R|

После 1NF:

|*Фирма*|Модели|
|-----|------|
|BMW|M5|
|BMW|X5M|
|BMW|M1|
|Nissan|GT-R|

 
### Вторая нормальная форма

- Таблица находится в 1НФ.
- Все неключевые атрибуты должны зависить от всего составного ключа, а не от его части.

До 2NF:

|*Модель*|*Фирма*|Цена|Скидка|
|------|-----|----|------|
|M5|BMW|5500000|5%|
|X5M|BMW|6000000|5%|
|M1|BMW|2500000|5%|
|GT-R|Nissan|5000000|10%|

После 2NF: ***Цена зависит от модели и фирмы, а скидка зависит только от фирмы***

|*Модель*|*Фирма*|Цена|
|------|-----|----|
|M5|BMW|5500000|
|X5M|BMW|6000000|
|M1|BMW|2500000|
|GT-R|Nissan|5000000|

|*Фирма*|Скидка|
|-----|------|
|BMW|5%|
|BMW|5%|
|BMW|5%|
|Nissan|10%|

### Третья нормальная форма

- Таблица находится в 2НФ.
- Все неключевые атрибуты должны зависеть только от первичного ключа.

До 3NF:

|*Модель*|Магазин|Телефон|
|------|-------|-------|
|BMW|Риал-авто|87-33-98|
|Audi|Риал-авто|87-33-98|
|Nissan|Некст-Авто|94-54-12|

После 3NF: ***Телефон не зависит от первичного ключа, а от магазина.***

|*Модель*|Магазин|
|------|-------|
|BMW|Риал-авто|
|Audi|Риал-авто|
|Nissan|Некст-Авто|

|*Магазин*|Телефон|
|-------|-------|
|Риал-авто|87-33-98|
|Риал-авто|87-33-98|
|Некст-Авто|94-54-12|

### Нормальная форма Бойса-Кодда или Частная форма 3NF

- Таблица в 3NF.
- Все неключевые атрибуты не должны зависеть от других неключевых.

До BCNF:

|*Номер стоянки*|Время начала|Время окончания|Тариф|
|---------------|------------|---------------|-----|
|*Номер стоянки*|Время начала|Время окончания|Тариф|
|1|09:30|10:30|Бережливый|
|1|11:00|12:00|Бережливый|
|1|14:00|15:30|Cтандарт|
|2|10:00|12:00|Премиум-В|
|2|12:00|14:00|Премиум-В|
|2|15:00|18:00|Премиум-А|

После BCNF: ***Номер стоянки зависит от тарифа, а также время окончания зависит от времени начала и тарифа***

|*Тариф*|Номер стоянки|
|-------|-------------|
|Бережливый|1|
|Cтандарт|1|
|Премиум-В|2|
|Премиум-А|2|

|*Тариф*|*Время начала*|Время окончания|
|-------|--------------|---------------|
|Бережливый|09:30|10:30|
|Бережливый|11:00|12:00|
|Cтандарт|14:00|15:30|
|Премиум-В|10:00|12:00|
|Премиум-В|12:00|14:00|
|Премиум-А|15:00|18:00|

### Четвертая нормальная форма

- Таблица в BCNF:
- Все многозначные зависимости должны быть удалены. То есть атрибуты зависят от первичного ключа, но не от друг друга.

До 4NF:

|*ID*|Проект|Хобби|
|--|----------------|--------------|
|1|Сантехник|Радиотехника|
|1|КайзерДом|Гитара|
|2|FabioRoss|Футфол|
|3|КайзерДом|Хоккей|
|3|Доска Почета|Гитара|

После 4NF: ***Проект и хобби зависят от ID, но не от друг друга. Это многозначная зависимость***

|*ID*|Проект|
|--|----------------|
|1|Сантехник|
|1|КайзерДом|
|2|FabioRoss|
|3|КайзерДом|
|3|Доска Почета|

|*ID*|Хобби|
|--|--------------|
|1|Радиотехника|
|1|Гитара|
|2|Футфол|
|3|Хоккей|
|3|Гитара|

### Пятая нормальная форма

- Таблица в 4NF.
- Отсутствуют сложные зависимости между атрибутами.
- Правило, которое крайне трудно найти на практике в чистом виде.

До 5NF:

|Производитель|Продукт|Поставщик|
|-------------|-------|---------|
|A|Продукт1|X|
|A|Продукт2|X|
|B|Продукт1|X|
|B|Продукт2|Y|

После 5NF: ***Присутствует трехсторонняя зависимость***

|*Производитель*|Продукт|
|-------------|-------|
|A|Продукт1|
|A|Продукт2|
|B|Продукт1|
|B|Продукт2|

|*Продукт*|Поставщик|
|-------|---------|
|Продукт1|X|
|Продукт2|X|
|Продукт2|Y|

|*Производитель*|Поставщик|
|-------------|---------|
|A|X|
|B|X|
|B|Y|

### Шестая нормальная форма

Та форма когда отношение уже неможет быть декомпозирована без потерь.

## Диаграммы "сущность-связь" или ER-диаграммы

**ER-диаграммы** используются для визуализации структуры БД на этапе проектирования.

### Основные элементы ER-диаграммы

- *Сущность*: объекты, которые надо хранить в БД.
- *Атрибуты*: свойства сущностей.
- *Связи*: отношения между сущностями.

### Уровни ER-диаграммы

- *Концептуальный уровень*: отображает только основные сущности и связи.
- *Логический уровень*: добавляет атрибуты и детали связей
- *Физический уровень*: конкретизация хранения, включая ключи и индексы.

### Методы разработки ER-диаграмм

1. **Определение сущностей** - выявление объектов, о которых нужно хранить данные.
2. **Определение атрибутов** - свойства сущностей.
3. **Определение связей между сущностями** - устанавливается, как объекты взаимодействуют друг с другом.
4. **Создание диаграммы** - используются специальные символы для сущностей, атрибутов и связей.

### Средства разработки ER-диаграмм

1. *Ручное рисование*
2. *Специализированные инструменты*: Lucidchart,Draw.io,Microsoft Visio,MySQL Workbench.

### Ограничения

- *Кардинальность*: определяет количество записей, связанных друг с другом(1:1, 1:N, M:N).
- *Обящательность*: показывает, может ли существовать без определенной сущность.

## Структура языка SQL

**SQL** - тьюринго-полные язык программирования, нацеленный на создания запросов к БД.
Состоит из нескольких DSL(Domain Specific Language): DDL, DML, DQL, TCL, DCL.

### DDL - Data Definition Language

**DDL** - используется для определения структуры базы данных.

- `CREATE TABLE`
- `ALTER TABLE`
- `DROP TABLE`

### DML - Data Manipulation Language

**DML** - используется для управления данными.

- `INSERT INTO`
- `UPDATE`
- `DELETE`

### DQL - Data Query Language

**DQL** - используется для извлечения данных. Основная команда `SELECT`.

Пример:

```sql
SELECT name,age FROM students WHERE age > 18;
```

### TCL - Transaction Control Language

**TCL** - используется для управления транзакциями.

- `COMMIT` - подтверждение.
- `ROLLBACK` - откат изменений.
- `SAVEPOINT` - создание точки отката.

### DCL - Data Control Language

**DCL** - используется для управления правами доступа.

- `GRANT` - предоставление прав.
- `REVOKE` - отзык прав.

## Типы данных SQL

Типы данных определяют, какие значения можно хранить в колонке таблицы.

### Числовые

- `INT, SMALLINT, BIGINT` - целые числа разной разрядности.
- `DECIMAL(p,s), NUMERIC(p,s)` - числа с фиксированной точностью.
- `FLOAT,REAL` - числа с плавающей точкой.

### Строковые

- `CHAR(n)` - строка фиксированной длины.
- `VARCHAR(n)` - строка переменной длины.
- `TEXT` - текстовые данные большой длины.

### Дата и время

- `DATE` - только дата.
- `TIME` - только время.
- `TIMESTAMP` - дата и время.

### Булевы

- `BOOLEAN` - значения TRUE,FALSE

## Операторы SQL

### Структура SQL-операторов

Операторы SQL структурированы по их назначения: DDL, DML, DQL, TCL, DCL. Смотреть выше.

### Нотации SQL

1. *Стандартная нотация* - поддерживается всеми СУБД.
2. *Расширенная нотация* - поддерживается только конкретной СУБД.

### Форматы конструкций

DDL:

```sql
CREATE TABLE students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    enrollment_date DATE
);

ALTER TABLE students
ADD COLUMN address VARCHAR(255);

DROP TABLE students;
```

DML:

```sql
INSERT INTO students (student_id, name, age, enrollment_date)
VALUES (1, 'Иван Иванов', 20, '2023-09-01');

UPDATE students
SET age = 21
WHERE student_id = 1;

DELETE FROM students
WHERE student_id = 1;
```

DQL:

```sql
SELECT name, age
FROM students
WHERE age > 18;

SELECT name, age
FROM students
ORDER BY age DESC;

SELECT COUNT(*) AS total_students
FROM students;
```

TCL:

```sql
BEGIN TRANSACTION;

UPDATE students
SET age = 22
WHERE student_id = 1;

COMMIT; -- Изменения сохраняются
-------------------
BEGIN TRANSACTION;

UPDATE students
SET age = 22
WHERE student_id = 1;

ROLLBACK;  -- Все изменения отменяются
-------------------
BEGIN TRANSACTION;

UPDATE students
SET age = 22
WHERE student_id = 1;

SAVEPOINT save1;  -- Создаем точку отката

UPDATE students
SET age = 23
WHERE student_id = 1;

ROLLBACK TO SAVEPOINT save1;  -- Откатываем изменения до save1

COMMIT;
```

DCL:

```sql
GRANT SELECT, INSERT ON students TO user1;

REVOKE SELECT, INSERT ON students FROM user1;
```

### Извлечение данных с использоывним SQL

Как было сказано выше, извлечение данных осуществляется с помощью команды `SELECT`.

Ключевые конструкции:

1. `WHERE`: фильтрация данных.
  ```sql
  SELECT name FROM employees WHERE SALARY > 50000;
  ```
2. `ORDER BY`: сортировка данных.
  ```sql
  SELECT name, salary FROM employees ORDER BY salary DESC;
  ```
3. `GROUP BY`: группировка данных.
  ```sql
  SELECT deparment, AVG(salary) FROM employees GROUP BY deparment;
  ```
4. `LIMIT`: ограничение количества возвращаемых строк.
  ```sql
  SELECT * FROM employees LIMIT 10;
  ```

### Обобщение данных с помощью агрегатных данных

**Агрегатные функции** позволяют обобщать данные.

Основные функции:

1. `COUNT`: количество строк.
  ```sql
  SELECT COUNT(*) FROM employees;
  ```
2. `SUM`: сумма значений.
  ```sql
  SELECT SUM(salary) FROM employees;
  ```
3. `AVG`: среднее значение.
  ```sql
  SELECT AVG(salary) FROM employees;
  ```
4. `MAX` и `MIN`: максимальное и минимальное значения.
  ```sql
  SELECT MAX(salary), MIN(salary) FROM employees;
  ```

### Многотабличные запросы, подзапросы

Для объединения данных из нескольких таблиц используют `JOIN`.

```sql
-- Многотабличный запрос
SELECT e.name, d.deparment_name
FROM employees e
JOIN deparments d ON e.deparment_id = d.id;
-- Подзапрос
SELECT name FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
```

### Соединения, теоретико-множественные и специальные операции над отношениями

Соединения:

1. `INNER JOIN`: только совпадающие строки.
2. `LEFT JOIN`: все строки из левой таблицы + совпадения.
3. `RIGHT JOIN`: все строки из правой таблицы + совпадения.
4. `FULL JOIN`: все строки из обоих таблиц.

```sql
SELECT e.name, d.deparment_name AS deparment
FROM employees e
LEFT JOIN deparments d ON e.deparment_id = d.id;
```

Теоретико-множественные операции:

1. `UNION`: объединение.
2. `INTERSECT`: пересечение.
3. `EXCEPT`: разность.

Специальные операции:

1. `CROSS JOIN`: возвращает все комбинации строк из двух таблиц.
2. `SELF JOIN`: используется для сопоставления строк в одной таблице.

### Группирование результатов запроса

Используется для логической группировки строк.

```sql
SELECT deparment_id, COUNT(*) AS employee_count FROM employees
GROUP BY deparment_id;
```

### Использованеи предложения UNION

Объединяет результаты двух или более запросов. Дублирующиеся строки исключаются.

!!!
Используйте `UNION ALL`, если нужны дублирующиеся строки.
!!!

```sql
SELECT name FROM employees
UNION
SELECT name FROM managers;
```

## Основные объекты языка SQL

### Таблицы

**Таблицы** - основные структуры для хранения данных.
  
```sql
CREATE TABLE employees(
id INT PRIMARY KEY,
name VARCHAR(100),
salary DECIMAL(10,2)
);
```

### Представления

**Представления** - логические таблицы, основанные на результатах запросов, или виртуальные таблицы, содержимое которых определяется запросом.
Они позволяют:

- Упрощать сложные запросы.
- Повышать безопасность, скрывая часть данных.
- Улучшать читаемость запросов.

```sql
CREATE VIEW active_employees AS
SELECT id, name, salary FROM employees
WHERE active = TRUE;

SELECT * FROM active_employees;
```

### Хранимые процедуры и функции

**Хранимые процедуры и функции** - программные блоки, хранящиеся и выполняемые на сервере базы данных.
Они позволяют:

- Повысить производительность за счет выполнения на сервере.
- Уменьшить передачу данных между клиентом и сервером.
- Повторно использовать код.

```sql
CREATE PROCEDURE add_employee(name VARCHAR(100), salary DECIMAL(10,2))
AS
BEGIN
    INSERT INTO employees(name, salary) VALUES(name, salary);
END;

CALL add_employee('name', 50.55);
--------
CREATE FUNCTION calculate_tax(price NUMERIC, tax_rate NUMERIC)
RETURNS NUMERIC AS $$
BEGIN
    RETURN price * tax_rate / 100;
END;
$$ LANGUAGE plpgsql;

SELECT calculate_tax(100, 20);
```

### Триггеры

**Триггеры** - код, который автоматически запускается при определенных событиях в таблице.
  
```sql
CREATE TRIGGER trigger_name
{BEFORE|AFTER|INSTEAD OF} {INSERT|UPDATE|DELETE}
ON table_name
FOR EACH ROW
BEGIN
-- Тело триггера
END;
```

### Индексы

**Индексы** - структуру для ускорения поиска данных. Они создают структуру данных, основанную на значениях одной или нескольких колонок таблицы.

1. *Кластерный индекс* - физически упорядочивает строки таблицы в соответствии со значением индекса.
  ```sql
  CREATE CLUSTERED INDEX idx_id ON employees(id);
  ```
2. *Некластерный индекс* - создает отдельную структуру, ссылающуюся на данные таблицы.
  ```sql
  CREATE INDEX idx_name ON employees(name);
  ```
3. *Уникальный индекс* - гарантирует уникальность значений.
  ```sql
  CREATE UNIQUE INDEX idx_email ON employees(email);
  ```

## Правила и стратегии поддерживания целостности данных

**Целостность данных** - обеспечивает корректность и согласованность данных в базе.

Основные правила которые надо соблюдать:

- Добавлять первичный ключ, он уникально идентифицирует каждую запись.
- Добавлять внешние ключи, они обеспечивают связь между таблицами.
- Добавлять `NOT NULL`, запрещает хранение пустых значений.
- Добавлять `CHECK`, накладывает ограничения на значения.

```sql
CREATE TABLE students(
    id INT PRIMARY KEY,
    age INT CHECK(age >= 18)
);
```

Стретегии:

- *Каскадное обновление и удаление*: `ON DELETE CASCADE ON UPDATE CASCADE`


## Методы совместного доступа к базам данных

Совместный доступ необходим, когда несколько пользователей работают с одной базой данных.

**Параллелизм** - выполнение нескольких операций одновременно.

**Конкуренция** - несколько транзакций обращаются к одним и тем же данным.

Типы параллелизма:

1. *Данные распределяются*: каждый запрос обрабатывает разные данные.
2. *Функциональный параллелизм*: каждая транзакция выполняет разные функции.

Механизмы совместного доступа:

- Блокировки
- Управление версиями данных

## Транзакции и блокировки

### Транзакции

**Транзакция** - последовательность операций, которая выполняется как единое целое.

Свойства транзакции:

1. *Атомарность*: либо все операции выполняются, либо ни одна.
2. *Согласованность*: после завершения данные остаются в корректном состоянии.
3. *Изолированность*: параллельные транзакции ни влияют друг на друга.
4. *Долговечность*: данные сохраняются даже после сбоя системы.

```sql
START TRANSACTION
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

!!!
Если транзакция не может быть завершена, используют `ROLLBACK`.
!!!

### Блокировки

- `EXCLUSIVE(исключительная)`: транзакция блокирует запись всех операций.
- `SHARED(разделяемая)`: несколько транзакций могут читать одну и ту же запись.

### Уровни изолированности пользователей

1. `READ UNCOMMITTED`: транзакции видят незавершенные изменения других транзакций.
2. `READ COMMITED`: транзакции видят только завершенные изменения.
3. `REPEATABLE READ`: запросы видят одно и то же состояние данных в пределах транзакции.
4. `SERIALIZABLE`: полная изолированность. Максимальная защита от конфликтов.

### Параллельное выполнение транзакций

Чтобы избежать конфликтов, применяются:

- Блокировки
- Уровни изолированности.

```sql
SELECT TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### Методы сериализации транзакций

**Сериализация** - порядок выполнения транзакций, обеспечивающих корректность данных.

Методы:

- *Протокол блокировок 2-фазного типа*: фаза1 - транзакция получает блокировки, фаза2 - транзакуия снимает блокировки.
- *Графы предшествования*: определяет порядок транзакций, чтобы избежать конфликтов.

## Проблема тупиковых ситуаций и ее решение

**Тупик(Deadlock)** - ситуация, которая возникает если две или более транзакции ожидают освобождения ресурсов друг другом.

Решение:

1. Построение графа ожидания. Если есть цикл, то это тупик.
2. Назначение тайм-аута для транкзакций.
3. Определение приоритетов транзакций.


## Синхронизационные захваты

**Синхронизация** - позволяет нескольким пользователям работать с базой одновременно без ошибок.

Механизмы:

- *Семафоры*: ограничивают количество одновременно выполняемых операций.
- *Мьютексы*: предотвращают одновременное выполнение критических операций.

## Распределенные базы данных

**Распределенные базы данных** - системы, в которых данные хранятся на нескольких серверах, расположенных в разных местах, и управляются как единое целое.

Задачи распределенных баз данных:

- Распределение данных
- Управление распределением
- Оптимизация запросов

Проблемы распределенных баз данных:

1. *Сеть*: низкая скорость или разрывы соединения влияют на доступ к данным.
2. *Целостность*: сложность обеспечения согласованности между серверами.
3. *Управление транзакциями*: необходимость глобального контроля транзакций.

## NoSQL

**NoSQL** - это тип СУБД, ориентированных на обработку больших объемов данных и высокую масштабируемость.

Особенности:

- Нерялиционная модель
- Свободная схема
- Простой API
- Распределенность

## Типы баз данных

1. Ключ-значения
2. Документоориентированные
3. Графовые базы данных
4. Колоночные базы данных
