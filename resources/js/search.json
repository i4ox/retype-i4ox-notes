[[{"l":"Начало всех начал","p":["Данный сайт предоставляет вам все мои заметки, сделанные во время изучения той или иной технологии. Здесь мы можете найти множество полезной информации.","Основные направления, которым я уделяю время:","Linux(Debian)","DevOps(мой основной профиль)","Golang(мой основной язык программирования)"]},{"i":"что-здесь-можно-найти","l":"Что здесь можно найти?"},{"l":"Руководства","p":["Настройка моей конфигурации Linux для выполнения DevOps задач","Данный сайт постоянно обновляется и улучшается. Если у вас есть идеи для улучшения не стесняйтесь оставить issue."]}],[{"l":"Установка OpenSuse Tumbleweed"},{"l":"Создание загрузочного USB накопителя"},{"l":"Установка Live CD образа","p":["Я буду ставить OpenSuse без установщика, то есть через консоль."]},{"i":"сжениеburn-iso-образа","l":"Сжение(Burn) ISO образа"},{"l":"Процесс установки"},{"l":"Запуск Live CD","p":["Как и с любой другой операционной системой или дистрибутивом Linux, мы должны войти в загрузочный образ ISO.","После того как мы это сделаем перед нами появится XFCE рабочий стол.","Запущенный Live CD","После этого требуется лишь открыть браузер с этим руководством и терминал."]},{"i":"опционально-настройка-ssh-для-доступа-к-системе","l":"(Опционально) Настройка SSH для доступа к системе","p":["Далее просто используем ssh linux@x.x.x.x."]},{"l":"Обновление Live CD","p":["Я считаю необходимым обновить весь инструментарий Live CD до последних версий."]},{"l":"Установка локалей","p":["Без настройки локалей будет возникать ряд ошибок во время установки."]},{"l":"Подготовка разделов на жестком диске","p":["+100% - Linux filesystem","1G - EFI Filesystem","4G - Linux swap","А также меняем тип раздела при необходимости.","Выбор типа раздела","Выбор типа файловой системы","Далее выбираем Write подтверждаем создание разделов и выходим.","Далее при помощи утилиты cfdisk необходимо настроить разделы на данном диске.","Для начала требуется узнать наименование необходимого жесткого диска. Делается это при помощи команды lsblk.","Запуск команды lsblk","Нам нужно три раздела:","Нам предложат выбрать тип системы, для UEFI выбираем gpt.","После чего создаем новый раздел и вводим количество необходимой памяти.","Создание раздела","Созданные разделы","Теперь при помощи все той же команды lsblk, мы можем увидеть, что разделы успешно создались."]},{"l":"Форматирование разделов"},{"l":"ext4"},{"l":"btrfs"},{"l":"Монтирование разделов"},{"i":"ext4-1","l":"ext4"},{"i":"btrfs-1","l":"btrfs","p":["Сначала надо создать все необходимые разделы.","Затем для btrfs отключить функционал Copy-On-Write. Чтобы улучшить производительность для VM и баз данных.","Далее необходимо создать конфигурацию для snapper. Вместо $DATE поставьте текущую дату и время. Например: 2025-01-05T15:30:00.","Устанавливаем этот снимок системы по-умолчанию для файловой системы root.","Далее создает нужные директории.","И теперь наконец-то монтирование системы."]},{"l":"Установка базовой системы","p":["Для btrfs также:"]},{"l":"Chrooting","p":["После чего перед нами будет терминал следующего вида.","Запущенный chroot"]},{"l":"Настройка fstab","p":["Для начала нам надо получить UUID всех трех разделов.","После чего мы открываем файл /etc/fstab и редактируем его по примеру ниже. Не забывая вставлять нужные UUID.","Для ext4:","Для btrfs subvolumes:"]},{"l":"Установка grub"},{"l":"Загрузка в систему"}],[{"l":"Git"},{"l":"Установка git","p":["Git можно установить либо из официального репозитория:","Либо из исходников:"]},{"l":"Настройка git","p":["Настройка git происходит через git config."]},{"l":"Хранения настроек","p":["Настройки могут храниться в трех местах:","/etc/gitconfig, если использовать git config --system;","~/.gitconfig если использовать git config --global;",".git/config если использовать git config --local.","Чтобы просмотреть все существующие настройки:"]},{"i":"username-и-useremail","l":"user.name и user.email","p":["Первое, что следует настроить эту имя и почту пользователя. Например:"]},{"i":"coreeditor","l":"core.editor","p":["Git нам позволяет явно указать редактор, который стоит использовать для коммитов, разрешения конфликтов и так далее. По-умолчанию значение считывается из переменной среды $EDITOR."]},{"i":"committemplate","l":"commit.template","p":["Позволяет задать шаблон для коммита."]},{"i":"corepager","l":"core.pager","p":["Определяет какая программа будет использована для разбиения текста на страницы."]},{"i":"mergetool","l":"merge.tool","p":["Указывает на инструмент, который надо использовать для команды mergetool."]},{"i":"diffexternal","l":"diff.external","p":["Указывает на инструмент, который надо использовать для сравнения."]},{"i":"initdefaultbranch","l":"init.defaultBranch","p":["Ветка, с которой проект создается по-умолчанию."]},{"i":"pullrebase","l":"pull.rebase","p":["Какое поведение git использовать при получении изменений."]},{"i":"alias","l":"alias.*","p":["Git позволяет создавать псевдонимы. Например:","Советуется добавить:"]},{"i":"coreexcludesfile","l":"core.excludesfile","p":["Какие файлы стоит игнорировать в проектах."]},{"i":"colorui","l":"color.ui","p":["Стоит ли подсвечивать большую часть вывода.","Можно отдельно для разных элементов: color.branch, color.diff, color.interactive, color.status."]},{"l":"Команды git"},{"l":"git help","p":["Выводит справочную информацию о той или иной команде."]},{"l":"git config","p":["Позволяет взаимодействовать с конфигурацией git."]},{"l":"git init","p":["Инициализирует новый проект."]},{"l":"git add","p":["Индексирует указанные файлы."]},{"l":"git commit","p":["Делает коммит с проиндексированными файлами."]},{"l":"git clone","p":["Клонирует существующий репозиторий."]},{"l":"git status","p":["Позволяет просматривать состояние файлов(Untracked, Unmodified, Modified, Staged)."]},{"l":"git diff","p":["Позволяет просматривать отдельные файлы на изменение содержимого."]},{"l":"git rm","p":["Удаление файла из индексации репозитория."]},{"l":"git mv","p":["Команда чтобы переименовать файл.","Является alias для команд ниже:"]},{"l":"git log","p":["Позволяет просматривать историю коммитов."]},{"i":"git-restore--git-reset","l":"git restore / git reset","p":["git restore это современная замена git reset.","Отменяет индексацию файла."]},{"l":"git remote","p":["Позволяет взаимодействовать с удаленными репозиториями."]},{"l":"git fetch","p":["Позволяет подгрузить изменение с определенного удаленного репозитория."]},{"l":"git pull","p":["Тот же git fetch, но для основного сервера, как правило, и более прост в использовании."]},{"l":"git push","p":["Отправка изменений в удаленный репозиторий."]},{"l":"git tag","p":["Позволяет задавать теги.","Теги нужно отдельно отправлять в удаленный репозиторий. Смотрите команду git push.","Также обратите внимание на удаление тега на удаленном репозитории, также через команду git push."]},{"l":"git show","p":["Позволяет просматривать информацию о файлах, деревьях, тегах и коммитах."]},{"l":"git checkout","p":["Позволяет переключаться между ветками."]},{"l":"git branch","p":["Позволяет создать новую ветку.","Новую ветку, созданную командой git branch --move, надо отправить в удаленный репозиторий."]},{"l":"git merge","p":["Позволяет провести слияние веток.","Иногда Git не может сам решить конфликты, и оставляет маркеры для того, чтобы их можно было разрешить вручную.","Пример:","В этом примере произошел конфликт текущей ветки с веткой iss53 в файле index.html."]},{"l":"git mergetool","p":["Открывает инструмент для разрешения конфликтов."]},{"l":"git ls-remote","p":["Позволяет просмотреть все удаленный ссылки в удаленном репозитории."]},{"l":"git rebase","p":["Накладывает все коммиты одной ветки поверх коммитов другой ветки."]},{"l":"git daemon","p":["Используется для настройки демона Git.","Флаги:","reuseaddr: перезапускает сервер без ожидания таймаута существующих подключений.","base-path: указывается путь, где хранятся проекты. Путь будет автоматически подставляться, то есть вместо /srv/git/nvops.git можно будет использовать nvops.git.","export-all: экспортирует все проекты в директории /srv/git/.","P.S: base-path влияет на git://.","P.P.S: вместо export-all можно добавлять в каждый репозиторий файл git-daemon-export-ok.","Однако команду выше стоит запускать через сервис. Как это делать можно посмотреть в пункте серверный git."]},{"l":"git instaweb","p":["Позволяет запустить веб-сервер для просмотра экземпляра GitWeb для текущего репозитория."]},{"l":"git reflog","p":["Позволяет просматривать журнул с привязкой к ссылкам:"]},{"l":"git stash","p":["Позволяет сохранить работу для того, чтобы вернуться к ней позже:"]},{"l":"git clean","p":["Удаляет непроиндексированные файлы:"]},{"l":"git grep","p":["Аналог grep, но для рабочего пространства git и поиска по его деревьям:"]},{"l":"git filter-branch","p":["Является сторонней утилитой - https://github.com/newren/git-filter-repo.","Используется для изменения истории коммитов."]}],[{"l":"SSH"},{"l":"Генерация ssh-ключей"},{"l":"Подключение по SSH"},{"l":"SSH-agent","p":["ssh-agent - менеджер ключей для SSH. Он хранит ваши ключи и сертификаты в памяти, незашифрованные и готовые к использованию ssh. Это избавляет вас от необходимости вводить пароль каждый раз, когда вы подключаетесь к серверу. Он работает в фоновом режиме в вашей системе, отдельно от ssh, и обычно запускается при первом запуске ssh.","Чтобы добавить пароль от приватного ключа:"]},{"l":"SSH-copy-id","p":["Чтобы скопировать ключ на сервер используем комманду ниже:","Не забываем про выдачу необходимых прав."]},{"l":"sshd_config"},{"l":"Лучшие практики","p":["Меняем порт с 22 на любой другой","PermitRootLogin no","PubkeyAuthentication yes","PasswordAuthencication no (исключительно после настройки ключей)","PermitEmptyPasswords no (не имеет смысла, если соблюдать 4 пункт)"]},{"l":"Настройки клиента","p":["Клиент SSH настраивается через файл ~/.ssh/config.","Пример настроек:","Далее делается подключение через команду ниже:"]},{"l":"Пробрасывание портов","p":["Командой выше мы создали подключение через SSH-туннель, с пробросом внешнего 8000 порта на локальный 9000 порт. И после этого НЕ ЗАКРЫВАЯ соединения, в другой вкладке терминала мы сможет обращаться по этому порту."]},{"l":"Моя конфигурация клиента SSH","p":["Ниже расположен пример моей конфигурации Linux"]}],[{"l":"Шпаргалка по Helm"},{"i":"что-такое-helm-и-зачем-он-нужен","l":"Что такое Helm и зачем он нужен?","p":["Helm- менеджер пакетов для Kubernetes, который позволяет:","Описывать приложения и их конфигурации в виде charts.","Устанавливать и управлять приложениями с помощью командной строки.","Упрощать обновление, удаление и версионирование приложений."]},{"i":"что-такое-helm-chart","l":"Что такое Helm Chart?","p":["Chart- набор файлов, описывающих Kubernetes-приложение. Он включает:","Шаблоны манифестов","Файлы конфигурации","Метаинформацию","Пример структуры:"]},{"i":"как-создать-helm-chart","l":"Как создать Helm Chart?"},{"i":"как-установить-приложение-с-помощью-helm","l":"Как установить приложение с помощью Helm?"},{"i":"что-такое-release","l":"Что такое Release?","p":["Release- установленная версия chart'а в кластере. Имя релиза позволяет управлять установленным приложением."]},{"i":"как-просмотретьт-установленные-releases","l":"Как просмотретьт установленные Releases?"},{"i":"как-удалить-release","l":"Как удалить Release?"},{"i":"что-такое-values","l":"Что такое Values?","p":["Values- настройки, которые влияют на генерацию манифестов. Они хранятся в values.yaml и могут быть переопределены при установке.","Способ через переопределение значений:"]},{"i":"как-работают-шаблоны-в-helm","l":"Как работают шаблоны в Helm?","p":["Шаблоны пишутся на языке Go Templates и используют директивы."]},{"i":"как-проверить-сгенерированные-манифесты","l":"Как проверить сгенерированные манифесты?"},{"i":"как-обновить-release","l":"Как обновить Release?"},{"i":"что-такое-helm-repository","l":"Что такое Helm Repository?","p":["Helm Repository- хранилище Helm Chart'ов.","Для работы с репозиториями есть команды.","Пример:"]},{"i":"что-такое-helm-hooks","l":"Что такое Helm Hooks?","p":["Helm Hooks- специальные шаблоны, которые выполняются на разных этапах жизненного цикла."]},{"i":"как-протестировать-helm-chart","l":"Как протестировать Helm Chart?"},{"i":"как-откатить-изменения","l":"Как откатить изменения?"},{"i":"как-работают-зависимости-в-helm","l":"Как работают зависимости в Helm?"},{"i":"что-такое-helm-secrets","l":"Что такое Helm Secrets?","p":["Для безопасного хранения секретов можно использовать плагин Helm Secrets, который шифрует файлы через SOPS."]},{"i":"как-настроить-cicd-в-helm","l":"Как настроить CI/CD в Helm?"},{"l":"Полезные команды Helm"}],[{"l":"Шпаргалка по Kubernetes"},{"i":"что-такое-kubernetes","l":"Что такое Kubernetes?","p":["Kubernetes- инфраструктурная платформа, содержащая в себе фреймворк для декларативного управления конфигурациями приложений на основе контейнеризации и виртуализации. Она является де-факто стандартом для оркестрации контейнеров, предоставляя богатый функционал для управления инфраструктурой, сетями, хранением данных и приложениями."]},{"i":"что-такое-pod","l":"Что такое POD?","p":["Pod- минимальная единица развертывания в Kubernetes, которая предоставляет собой группу контейнеров, объединенных общей сетью(общий localhost, общий внешний IP) и общими ресурсами. Контейнеры внутри POD работают в тесной связке."]},{"i":"для-чего-при-старте-podа-создается-контейнер-с-процессом-pause","l":"Для чего при старте PODа создается контейнер с процессом pause?","p":["Для того чтобы создать сетевую изоляцию Kubernetes при старте POD'а запускает специальный контейнер pause. Он отвечает за управление сетью и обеспечивает контейнерам внутри POD'а возможность взаимодействовать через localhost. Он не выполняет реальную работу, а является посредником при сетевом взаимодействии."]},{"i":"как-можно-запускать-поды","l":"Как можно запускать поды?","p":["POD'ы обычно запускаются с помощью workloads, которые обеспечивают управление жизненным циклом POD'ов.","Примеры:","(ReplicationController) Deployment- для развертывания и управления репликами POD'ов с возможность откатов.","StatefulSet- для приложений с состоянием, которые требуют уникальности и постоянства идентификаторов.","DaemonSet- для запуска одного POD'а на каждом узле кластера.","Job- для запуска одноразовых задач.","CronJob- для запуска задач по расписанию."]},{"i":"в-чем-разница-между-deployment-и-statefulset","l":"В чем разница между Deployment и StatefulSet?","p":["В именах: у первого некий случайный хэш, у второго - порядковый номер.","В работе с дисками: StatefulSet дожидается пока POD с таким же именем завершит работы, чтобы занять тот диск, который был к нему привязан.","В стратегиях перезапуска POD'ов при обновлении."]},{"i":"что-такое-replicaset","l":"Что такое ReplicaSet?","p":["ReplicaSet- это объект, который управляет количеством реплик POD'ов в Kubernetes. ReplicaSet гарантирует, что в любой момент времени будет существовать определенное количество копий POD'ов. В Kubernetes обычно используют Deployment, который управляет ReplicaSet."]},{"i":"что-такое-kubernetes-probes","l":"Что такое Kubernetes probes?","p":["Проверки состояния контейнера - механизмы для мониторинга состояния приложений и контейнеров.","Kubernetes поддерживает три вида проверок:","Startup probe- проверка, которая используется для определения, когда контейнер полностью инициализировался. Если эта проверка не проходит, другие пробы не выполняются.","Readiness probe- проверка готовности контейнера к обслуживанию трафика. Если она не проходит, контейнер не будет получать трафик.","Liveness probe- проверка живости контейнера. Если она не проходит, контейнер перезапускается."]},{"i":"какие-хорошие-практики-существуют-при-создании-проб","l":"Какие хорошие практики существуют при создании проб?","p":["Пробы должны проверять рабочие и критические компоненты приложения, чтобы гарантировать, что приложение может обрабатывать запросы пользователя.","Пробы не должны быть слишком частыми или тяжелыми, чтобы не создавать дополнительную нагрузку на систему.","Пробы не должны зависеть от внешних сервисов, если только это не критично для работы приложения.","Используйте сквозные проверки, если приложение имеет несколько взаимосвязанных сервисов."]},{"i":"что-такое-pod-disruption-budget","l":"Что такое Pod Disruption Budget?","p":["Pod Disruption Budget (PDB)- механизм, который гарантирует, что в кластере всегда будет доступно минимальное количество POD'ов для определенного приложения. PDB помогает предотвратить слишком большое количество перерывов в работе приложения при обслуживании или удалении POD'ов."]},{"i":"что-такое-priority-classes","l":"Что такое priority classes?","p":["Priority Classes- механизм, который позволяет назначать приоритеты POD'ам, чтобы Kubernetes мог управлять распределением ресурсов между POD'ами с разными приоритетами, особеннос в случае нехватки ресурсов."]},{"i":"что-такое-pod-eviction","l":"Что такое POD eviction?","p":["Eviction- процесс удаления POD'ов с узлов, когда ресурсы на узле становятся дефицитными(нехватки памяти или диска). Kubernetes может эвакуировать POD'ы с низким приоритетом, чтобы освободить ресурсы для более важных приложений."]},{"i":"каким-образом-можно-управлять-размещением-podов-на-конкретных-нодах-кластера-k8s","l":"Каким образом можно управлять размещением PODов на конкретных нодах кластера k8s?","p":["NodeSelector/Node Affinity- позволяет указать, на каких узлах можно запускать POD'ы, основываясь на метках нод.","Taints/Tolerations- механизм, который запрещает или разрешает запуск POD'ов на определенных узлах в зависимости от их меток.","Pod Affinity/Anti-Affinity- механизм, позволяющий задавать правила для размещения POD'ов на одних или разных узлах в зависимости от меток."]},{"i":"каким-образом-можно-управлять-вычислительными-ресурсами-в-k8s","l":"Каким образом можно управлять вычислительными ресурсами в k8s?","p":["Resources requests и limits позволяют управлять количеством ресурсов, которое контейнер может использовать.","Request- минимальное количество ресурсов, которое контейнер гарантировано получит.","Limits- максимальное количество ресурсов, которое контейнер может использовать."]},{"i":"что-такое-kubernetes-service","l":"Что такое Kubernetes service?","p":["Service- абстракция, которая позволяет организовывать доступ к приложениям, работающим в Kubernetes, через постоянный IP-адрес или DNS-имя. Сервис может выполнять балансировку трафика между POD'ами."]},{"i":"каким-образом-можно-предоставить-приложение-которые-работает-в-кластере-пользователям","l":"Каким образом можно предоставить приложение, которые работает в кластере, пользователям?","p":["Если приложение работает по HTTP, то можно использовать Ingress-контроллер. Ingress позволяет маршрутизировать HTTP/HTTPS-трафик от пользователей к приложениям в кластере.","Если приложение работает по бинарному протоколу(PostgreSQL), то обычно используют Service с типом NodePort или LoadBalancer, чтобы сделать его доступным извне."]},{"i":"почему-ingress-удобен","l":"Почему Ingress удобен?","p":["Используя Ingress, можно управлять маршрутизацией трафика для всех приложений внутри кластера через одну точку входа. Это позволяет эффективно управлять HTTP/HTTPS-трафиком, используя такие функции как:","Балансировка нагрузки","Поддержка HTTPS","Маршрутизация по поддоменам или URL","Поддержка канареечных развертываний"]},{"i":"каким-образом-организована-сеть-в-k8s","l":"Каким образом организована сеть в k8s?","p":["В Kubernetes существует три типа сети:","Node Network- сеть, в которую объединены ноды. В зависимости от использования CNI-плагина, ноды могут работать только в одной подсети, либо в нескольких.","Pod Network- сеть, в которой получают IP-адреса запускаемые PODы.","Service Network- сеть, в которой получают адреса Kubernetes services.","Pod network и service network орнанизуются при помощи так называемых CNI-плагинов."]},{"i":"что-такое-cni-плагин-и-для-чего-он-нужен","l":"Что такое CNI-плагин и для чего он нужен?","p":["CNI расшифровывается как Container Network Interface. Он представляет собой некий уровень абстракции над реализацией сети. Мы может работать с верхнеуровневыми абстракциями вроде \"IP-адрес POD'а\", Endpoint. За то как это будет реализовано на физическом уровне отвечают CNI-плагины, которые реализуют разный функционал и показывают разную сетевую производительность.","Примеры CNI-плагинов:","Flannel","Calico","Cilium"]},{"i":"что-такое-egress","l":"Что такое EGRESS?","p":["EGRESS- возможность назначить внешний IP-адрес для исходящего за пределы кластера k8s трафика приложений. Поддержка EGRESS должна быть реализована на уровне CNI-плагина и может быть описана специальным объектом на уровне неймспейса."]},{"i":"как-мы-можем-ограничить-трафик-в-kubernetes","l":"Как мы можем ограничить трафик в Kubernetes?","p":["Для ограничения трафика от приложений используется объект NetworkPolicy. При помощи него мы можем ограничивать входящий и исходящий трафик на уровне неймспейса и компонентов, описанных в нем. Его поддержка должна быть реализована на уровне CNI-плагина."]},{"i":"что-такое-service-mesh-и-для-чего-он-нужен","l":"Что такое Service Mesh и для чего он нужен?","p":["Service Mesh- паттерн, позволяющий более гибко управлять трафиком в Kubernetes. Servise Mesh состоит из:","control plane, который собирает информацию о кластере k8s","запущенных в нем приложениях","дополнительных объектов, которые могут быть описаны для дополнительной конфигурации","sidecar-контейнеров, которые инжектятся в POD'ы автоматически при помощи mutation webhook.","Sidecar-контейнеры- reverse-прокси, перехватывающие входящий и исходящий трафик приложений в контейнерах и управляющие им в зависимости от полученной из control plane конфигурации.","Основные задачи для Service Mesh:","Гарантий доставки трафика до приложений(retry, timeouts, circuit breaker)","Увеличение безопасности при помощи шифрования трафика, верификации трафика на основе сертификатов, реализация дополнительных правил и разрешений на передачу трафика","Реализация переключения трафика при canary, a/b, blue/green стратегий деплоя.","Недостатки:","Избыточная сложность","Повышенная ресурсоемкость","Накладные расходы"]},{"i":"в-чем-отличие-меток-от-аннотаций","l":"В чем отличие меток от аннотаций?","p":["Метки используются для реализации механизмов поиска и группировки объектов. Аннотации используются для описания метаинформации на объекте."]},{"i":"из-каких-компонентов-состоит-k8s-и-каково-их-назначение","l":"Из каких компонентов состоит k8s и каково их назначение?","p":["Kubernetes состоит из control plane и data plane.","Control Plane- управляющий контур, который запускается в пределах нод, называемых master, и может запускаться как одиночном режиме( single master), так и в распределенном( multi master).","Control plane содержит:","ETCD- хранилище конфигурации кластера","Kubernetes API- предоставляет API, посредством которого взаимодействуют компоненты k8s, а также клиенты находящиеся внутри и вне кластера.","Kubernetes Controller Manager- реализует концепцию контроллеров, которые управляют базовыми сущностями кластеров.","Kubernetes scheduler- выбирает ноды, на которых нужно запускать PODы.","Cloud controller manager- используется для реализации функций работы с облаком.","Data plane- компоненты, которые запущены на каждой ноде.","kubelet- следит за изменениями конфигурации ноды, применяет конфигурации, делает пробы контейнеров, отчитывается о статусе контейнеров, работает с CRI-плагином и реализует функции запуска и остановки контейнеров.","kube-proxy- отвечает за сетевой компонент. Работает с CNI-плагином и обеспечивает функционрирование сущности Service в пределах своей ноды."]},{"i":"что-такое-kube-proxy-и-для-чего-он-нужен","l":"Что такое kube-proxy и для чего он нужен?","p":["kube-proxy- компонент data plane, который работает на каждой ноде. Он взаимодействеут с CNI-плагином, обеспечивая функционирование pod network. А также обеспечивает функционирование описанных в кластере сервисов в пределах своей ноды. В зависимости от режима выступает либо в роли прокси, либо как контроллер правил IPTABLES/IPVS."]},{"i":"что-такое-cri","l":"Что такое CRI?","p":["CRI расшифровыется как Container Runtime Interface. Это спецификация, описывающая некий уровень абстракции, который позволяет унифицированно использовать разные версии ПО для работы с контейнерами, например containerd или CRI-O."]},{"i":"какие-типы-volumов-можно-использовать-в-kubernetes","l":"Какие типы volum'ов можно использовать в Kubernetes?","p":["hostpath, но тогда POD должен быть привязан к ноде.","local-storage - автоматически привязывает POD, который его использует, к нужной ноже.","Также можно использовать сетевые диски при помощи CSI-плагинов."]},{"i":"что-такое-csi-плагин","l":"Что такое CSI-плагин?","p":["CSI расшифровывается как Container Storage Interface. Это абстракция, позволяющая унифицированно использовать сетевые файловые системы, построенные на разных технологических базах.","Мы описываем storageClass, соответствующий дискам определенного типа, и деплоим в кластер provisioner.","Provisioner- специальное ПО, которое может заказывать сетевые диски в системе, способной их предоставлять.","Далее мы описываем объект persistentVolumeClaim с указанием нужного storageClass.","Provisioner при появлении PVC заказывает диск нужного размера в системе, которая их предоставляет, создает объект persistentVolume и привязывает его к PVC. Когда происходит запуск POD'а на ноде, соотвествующий диск монтируется на нужную ноду по определенному пути, и этот путь монтируется на файловую систему PODа."]},{"i":"каким-образом-мы-можем-разделить-права-на-kubernetes","l":"Каким образом мы можем разделить права на Kubernetes?","p":["Для разделения прав в Kubernetes применяется механизм Role Based Access Control(RBAC). В рамках него есть три группы сущностей:","user или service account- который описывает субъект доступа.","role или cluster role- который описывает разрешения.","roleBinding или clusterRoleBinding- который привязывает списки разрешений к субъекту."]},{"i":"в-чем-отличие-service-account-от-user","l":"В чем отличие service account от user?","p":["User не имеет записей в Kubernetes API, управление осуществляется внешними механизмами. Они предназначены для событий вне кластера."]},{"i":"какие-механизмы-аутентификации-используются-в-kubernetes","l":"Какие механизмы аутентификации используются в Kubernetes?","p":["Kubernetes может использовать:","сертификаты X509","Bearer-токены","аутентифицирующий прокси","HTTP Basic Auth","При помощи этих механизмов можно реализовывать большое количество схем авторизации: от статичного файла с паролями до OpenID OAuth2.","Более того, допускается применение нескольких схем авторизации одновременно. По умолчанию используются:","service account tokens - для Service Accounts","X509 - для Users"]},{"i":"что-такое-namespace-в-k8s-и-для-чего-он-нужен","l":"Что такое namespace в k8s и для чего он нужен?","p":["Участвует в формировании DNS-имен внутри кластера. [service name].[namespace].[суффикс кластера].","Суффикс по-умолчанию: svc.cluster.local."]},{"i":"что-такое-финалайзеры-и-для-чего-они-нужны","l":"Что такое финалайзеры и для чего они нужны?","p":["Это специальные ключи в манифесте объекта, описывающие действия, которые требуется совершить до удаления обзъекта."]}]]