[[{"i":"#","p":["Маскот языка программирования Go"]},{"l":"Начало всех начал","p":["Данный сайт предназначен для хранения моих заметок и ссылок на документацию различных технологий. Я не несу ответственности за постоянную доступность сайта, за достоверность информации и за ее актуальность."]},{"l":"Что можно найти здесь","p":["Информацию о инструментах и технологиях, которые я использую в работе","Шаблоны и примеры кода","Теоритические материалы по алгоритмам и структурам данных, базам данных и т.д.","Огромный пласт информации о Golang","Данный сайт постоянно обновляется и улучшается. Если у вас есть идеи для улучшения не стесняйтесь оставить issue."]}],[{"l":"Администрирование Linux"},{"l":"Краткая сводка по командам"},{"l":"Пользователи и группы","p":["Создание пользователей: useradd, passwd","Изменение пользователей: usermod","Удаление пользователей: userdel","Создание групп: groupadd","Изменение групп: groupmod","Удаление групп: groupdel","Работа с sudo: visudo, sudoers"]},{"l":"Основы Linux","p":["Linux— это операционная система с многозадачностью, многопользовательской поддержкой и строгими правами доступа."]},{"i":"fhs---filesystem-hierarchy-standard","l":"FHS - Filesystem Hierarchy Standard","p":["/- корневой каталог, точка начала всей файловой системы.","/bin- основные исполняемые файлы.","/boot- загрузочные файлы.","/dev- устройства, представленные как файлы.","/etc- конфигурационные файлы.","/home- домашние каталоги пользователей.","/lib, /lib64- системные библиотеки.","/media, /mnt- точки монтирования внешних устройств.","/opt- файлы для дополнильных программ.","/proc- виртуальная файловая система(информация о процессах и системе).","/root- корневой каталог root-пользователя.","/run, /tmp- временные файлы.","/sbin- системные утилиты.","/srv- сервисные файлы.","/sys- системные файлы.","/usr- программы и библиотеки для пользователей.","/var- изменяемые данные(логи, кеши, почта)","В Linux все файлы организованы в виде древовидной структуры с корнем /.","Основные директории:"]},{"i":"права-доступа-chmod-chown-unmask","l":"Права доступа (chmod, chown, unmask)","p":["Каждый файл в Linux имеет владельца, группу и права. При просмотре файлов можно увидеть их права:","Обозначения прав:","Символ","Значение","-","файл(если d- каталог)","rw-","владелец: чтение( r), запись( w), нет выполнения(-)","r--","группа: только чтение","остальные пользователи: тоько чтение","Чтобы изменить права доступа, используется команда chmod.","Через команду umask можно установить какие права НЕ УСТАНАВЛИВАТЬ при создании файла.","Также можно сменить владельца файла, используя команду chown."]},{"l":"Основные комманды","p":["Работа с файлами и каталогами:","Поиск файлов:","Работа с текстовыми файлами:","Перенаправление вывода:"]},{"l":"Процессы"},{"l":"Просмотр процессов"},{"l":"Управление процессами"},{"i":"приоритет-процессов-nice-renice","l":"Приоритет процессов (nice, renice)"},{"l":"Управление пользователями и группами","p":["В Linux пользователи могут быть обычными или системными. Системные пользователи используются для служб-демонов.","Группы- компонент системы, который позволяет управлять правами доступа к файлам и ресурсам."]},{"l":"Создание пользователя","p":["Создать пользователя можно с помощью команды useradd.","По-умолчанию:","Пользователь создается без домашней директории.","Используется /etc/skel для шаблона конфигурации пользователя.","Чтобы создать пользователя с домашней директорией:","Ниже приведена полная команда со всеми популярными опциями.","Опции:","-m- создать домашнюю директорию для пользователя","-s- указать путь к оболочке для пользователя","-c- указать описание пользователя","-G- указать группы пользователя","-g- указать основную группу пользователя"]},{"l":"Смена пароля пользователя","p":["После создания пользователя ему нужно задать пароль.","Если надо сменить текущему пользователю, то можно использовать просто passwd."]},{"l":"Изменение параметров пользователя","p":["Если нужно изменить уже существующего пользователя, используется команда usermod.","Флаг -a используется для добавление пользователя в группу, без удаления из старых."]},{"l":"Удаление пользователя","p":["Если нужно удалить пользователя, используется команда userdel.","Правда этот вариант оставляет домашнюю директорию пользователя, чтобы удалить ее используется команда ниже."]},{"l":"Управление группами","p":["Создать новую группу:","Изменить существующую группу:","Удалить группу:","Группу нельзя удалить, если она содержит пользователей."]},{"l":"Просмотр информации о группах и пользователях","p":["Узнать основную группу пользователя:","Проверить в каких группах состоит пользователь:"]},{"l":"Sudo и политика доступа","p":["Sudo позволяет временно выполнять команды от имени суперпользователя."]},{"l":"Добавление пользователя в sudo","p":["Чтобы дать права суперпользователя пользователю:"]},{"l":"Файл конфигурации sudoers","p":["Настройка sudo хранится в файле /etc/sudoers. Изменять его вручную не рекомендуется, лучше использовать:","Пример строки для добавления пользователя в sudo. Эта команда дает полный доступ к sudo."]},{"l":"Запрет на запрос пароля при использовании sudo","p":["Можно запретить запрос пароля при использовании sudo:","Это может быть небезопасно!"]},{"l":"Ограничение команд для sudo","p":["Можно ограничить команды, которые могут быть выполнены с помощью sudo:","В данном примере без запроса пароля можно выполнить команду sudo service nginx restart."]},{"l":"Управление пакетами в Linux","p":["Linux использует пакетные менеджеры для устаноки, обновления и удаления программ. В зависимости от дистрибутива используются разные системы управления пакетами."]},{"i":"debian-basedapt-dpkg","l":"Debian-based(APT, DPKG)","p":["APT(Advanced Package Tool)- это высокоуровневый менеджер пакетов для Debian, Ubuntu и их производных. Он работает поверх dpkg, который является низкоуровневым инструментов установки .deb пакетов.","Работа с apt:","Работа с dpkg:"]},{"i":"redhat-basedyum-dnf-rpm","l":"RedHat-based(YUM, DNF, RPM)","p":["YAM(Yellowdog Updater, Modified) и DNF(Dandifined YUM) используются в RHEL, CentOS и Fedora.","RPM(RedHat Package Manager)- это низкоуровневый инструмент работы с .rpm пакетами.","Работа с dnf(современный пакетный менеджер):","Работа с yum(старый пакетный менеджер, используется в CentOS 7 и RHEL 7):","Работа с rpm:"]},{"i":"компиляция-из-исходниковmake-gcc-tar-configure","l":"Компиляция из исходников(make, gcc, tar, ./configure)","p":["Если нужного пакета нет в репозитории, можно установить его из исходников."]},{"l":"Управление дисками и файловыми системами в Linux","p":["Linux предоставляет мощные инструменты для разметки дисков, работы с файловыми системами, управления LVM и RAID, а также шифрования данных с помощью LUKS."]},{"i":"разметка-дисков-fdisk-parted","l":"Разметка дисков (fdisk, parted)","p":["Перед использование любого диска его необходимо разметить, а затем создать файловую систему.","Чтобы вывести список дисков и разделов, можно использовать команду lsblk:","А чтобы посмотреть информацию о дисках, можно использовать команду fdisk -l:","Разметка диска с помощью fdisk:","Основные команды для fdisk:","n- создать новый раздел","d- удалить раздел","w- записать изменения","p- показать таблицу разделов","q- выйти из разметки","Разметка диска с помощью parted:"]},{"i":"файловые-системыext4-xfs-btrfs-zfs","l":"Файловые системы(ext4, xfs, btrfs, zfs)","p":["Создание файловых систем:","Проверка и исправления файловой системы:"]},{"l":"Монтирование дисков и fstab","p":["После создания файловой системы, диск нужно подключить в систему.","Временное монтирование диска делается с помощью команды mount:","Для того, чтобы размонтировать временно монтированный диск, используется команда umount:","Если диск нужно примонтировать в систему на постоянной основе, то можно использовать файл fstab. Но сначала надо опредилить UUID нужного нам диска. Это можно сделать рядом способов:","После чего добавить строку ниже в файл /etc/fstab:","Чтобы применить изменения в fstab без перезагрузки системы:"]},{"l":"RAID","p":["2","3","4","RAID 0 (Stripting)","RAID 1 (Mirroring)","RAID 10","RAID 5","RAID 6","RAID уровень","RAID– это способ объединения нескольких дисков в один для более высокой производительности, или для того, чтобы они работали как один том.","Высокая","Высокая(но запись медленнее из-за вычисления паритета)","Высокая(один из дисков может выйти из строя)","Высокая(чтение и запись)","Двойной паритет(выдерживает отказ 2 дисков)","Запись медленнее, чем RAID 5","Зеркалирование + чередование(RAID 0 + RAID 1)","Минимальное количество дисков","Надежность","Нет защиты данных","Один диск можно потерять","Описание","Отличная","Очень высокая","Полное зеркалирование данных","Производительность","Разделение данных между дисками, без избыточности","Упралять RAID можно с помощью команды mdadm:","Уровни RAID:","Чередование данных с паритетом","Чтобы просмотреть статусы RAID:","Чуть ниже, чем одиночный диск"]},{"l":"LVM","p":["LVM— это дополнительный слой абстракции от железа, позволяющий собрать кучи разнородных дисков в один, и затем снова разбить этот один именно так как нам хочется. Реализовано с помощью подсистемы device-mapper.","PV(Physical Volume)— физические тома(могут быть разделы или целые \"неразбитые\" диски). VG(Volume Group)— группа томов(объединяем физические тома в группу, создаем единый диск, который дальше будет разбивать так, как нам хочется). LV(Logical Volume)— логические разделы, собственно раздел нашего нового \"единого диска\", группы томов, который мы потом форматируем и используем как обычный раздел, обычного жесткого диска.","Создание физического тома:","Создание группы томов:","Создание логического тома:","Форматирование и монтирование тома:"]},{"l":"Шифрование дисков с LUKS","p":["LUKS(Linux Unified Key Setup)— стандартное решение для шифрования дисков в Linux.","Установка LUKS:","Создание зашифрованного раздела LUKS:","Удалит все данные!","Открытие зашифрованного раздела LUKS:","Теперь зашифрованный раздел будет доступен под именем /dev/mapper/cryptdisk.","Форматирование и монтирование зашифрованного раздела:","Автоматическое монтирование делается при помощи /etc/crypttab и /etc/fstab:","Закрытие зашифрованного раздела LUKS:"]},{"l":"Система инициализации и службы","p":["В Linux управление службами и процессами играет ключевую роль в администрировании. Основная система инициализации - systemd, но также существуют альтернативные системы( SysVinit, Upstart, runut, OpenRC, dunit, s6 и т.д.)."]},{"l":"systemd","p":["systemd- это основной системный менеджер инициализации в большинстве современных дистрибутивов.","Чтобы проверить используется ли systemd:","Основные команды systemd:","Проверка статуса службы:","Автозагрузка сервисов при старте системы:","Проверить включен ли автозапуск службы:","Проверка всех запущенных служб:"]},{"l":"Написание собственных служб","p":["Службы в systemd описываются в unit-файлах(.service).","Создание простого сервиса:","Пример unit-файла:","Включение службы в автозапуск:"]},{"l":"Таймеры systemd","p":["Пример unit-файла:","Включение таймера в автозапуск:"]},{"l":"Резервное копирование и восстановление","p":["Резервное копирование- важная часть администрирования системы. В Linux есть несколько инструментов.","Инструмент","Описание","rsync","Инкрементальное копирование файлов по сети","tar","Архивация файлов и директорий","dd","Клонироваие дисков и разделов","scp","Копирование файлов по сети","BorgBackup","Эффективное дедуплицированное резервное копирование"]},{"l":"rsync"},{"l":"tar"},{"l":"dd"},{"l":"scp"},{"l":"BorgBackup","p":["Установка:","Использование:"]},{"i":"снапшотыlvm-zfs-btrfs","l":"Снапшоты(LVM, ZFS, Btrfs)","p":["LVM снапшоты:","ZFS снапшоты:","BTRFS снапшоты:"]},{"l":"Безопасность в Linux","p":["Основные аспекты безопасности в Linux:","Контроль доступа: SELinux, AppArmor","Защита от атак: fail2ban","Аудит системы: чек-листы безопасности"]},{"i":"selinuxsecurity-enhanced-linux","l":"SELinux(Security-Enhanced Linux)","p":["Режимы SELinux:","enforcing- принудительно включен","permissive- включен, но принудительно отключен","disabled- выключен"]},{"l":"AppArmor"},{"i":"fail2ban---защита-от-брутфорса","l":"Fail2ban - защита от брутфорса","p":["Fail2ban блокирует IP-адреса после нескольких неудачных попыток входа.","Настройка fail2ban(/etc/fail2ban/jail.local):","Перезапуск fail2ban:","Просмотр заблокированных IP-адресов:"]},{"l":"Чек-листы безопасности","p":["Обновление системы.","Ограничение sudo доступа( visudo).","Отключение ненужных служб.","Защита паролей:","Мониторинг логов."]},{"l":"Журналирование и мониторинг","p":["Журналирование и мониторинг помогают ослеживать состояние системы, выявлять проблемы и анализировать производительность."]},{"l":"Логирование","p":["journald- системный журнал systemd. Он хранит логи в бинарном формате и управляется через journalctl.","syslog и rsyslog- традиционное логирование. Они записывают логи в текстовые файлы, такие как /var/log/syslog и /var/log/auth.log.","Настройка филтрации логов в /etc/rsyslog.conf.","Запись выше отправляет логи с процесса sshd в файл /var/log/ssh.log.","После изменения настроек надо перезапустить службу rsyslog."]},{"l":"Мониторинг ресурсов","p":["Команда","Описание","htop","Графический просмотр процессов","iostat","Нагрузка на диски","vmstat","Использование CPU, памяти","free","Свободная память","sar","Сбор статистики нагрузки","Примеры:"]},{"l":"Инструменты мониторинга","p":["Nagios:","Мониторинг серверов и сетевого оборудования.","Проверка доступности (ping, HTTP, SSH).","Оповещения (email, Telegram, Slack).","Zabbix:","Сбор данных (CPU, память, диск).","Графики и триггеры.","Агенты для Windows/Linux.","Prometheus + Grafana:","Сбор метрик(CPU, память, сети).","Интеграция с Kubernetes, Docker.","Визуализация данных через Grafana."]},{"l":"Виртуализация и контейниризация","p":["Безопасность","Виртуализация","Виртуализация и контейниризация- это технологии, позволяющие запускать несколько изолированных сред на одном физическом сервере, но у них разные принципы работы.","Все контейнеры используют одно ядро","Высокая(отдельные ядра)","Гибкость","Запуск","Изоляция","Использует ядро хоста","Контейниризация","Легковесная","Меньше изоляции, но можно использовать SELinux, AppArmor","Минуты(из-за загрузки ОС)","Можно запускать разные ОС","Параметр","Полноценная ОС с ядром","Ресурсы","Секунды","Требует больше CPU/RAM"]},{"l":"Виртуализация","p":["QEMU/KVM- нативная виртуализация на ядре Linux.","Proxmox VE- мощная виртуализация на базе KVM. Proxmox- платформа для управления виртуальными машинами и контейнерами.","Установка Proxmox VE:","Скачиваем ISO с официального сайта.","Устанавливаем на сервер.","Управляем через web-интерфейс.","VMWare ESXi- коммерческий гипервизор для виртуализации в дата-центрах.","Hyper-V- виртуализация от Microsoft для Windows Server.","VirtualBox- простая виртуализация для тестов"]},{"l":"Контейнеризация","p":["Docker- основной инструмент контейнеризации.","Контейнеризация и Docker разберу отдельно.","Podman- альтернатива Docker без демона.","Kubernetes- оркестрация контейнеров. Он управляет кластерами контейнеров, балансировкой нагрузки и масштабированием.","Kubernetes разберу отдельно."]}],[{"l":"Алгоритмы"},{"i":"что-такое-алгоритм","l":"Что такое алгоритм?","p":["Алгоритм- набор инсрукций для выполнения некоторой задачи. Хотя, в принципе, любой фрагмент кода можно считать алгоритмом."]},{"i":"что-такое-о-большое","l":"Что такое О-большое?","p":["Специальная нотация \"О-большое\" описывает скорость работы алгоритма.","Предположим, у нас ограничение в 100мс и надо проверить 100 элементов - Пусть 1мс это тоже самое что и 1 операция.","Для простого алгоритма можно считать это скоростью O(100), то есть 100мс.","А в случае с бинарным поиском это скорость О(log100), то есть 7мс.","2^ 6 = 64","2^ 7 = 128","64 < 100 < 128","Можно сказать, что О( количество операций), то есть это обозначение того сколько операций понадобится в худшем случае."]},{"l":"Типичные варинты О-большого","p":["0.4c","0.8c","1.0c","1.2 дня","1.6c","1.7мин","1.8ч","1024","16","17мин","25.6c","256","3.4мин","5.4 * 10^ 2438 лет","6.4c","66301 лет","8.6 * 10^ 505 лет","Количество элементов","О(log n)","О(log n) - логарифмическое время. Пример: бинарный поиск.","О(n * log n)","О(n * log n) - логарифмическое время. Пример: эффективные алгоритмы сортировки.","О(n!)","О(n!) - факторическое время. Пример: очень медленные алгоритмы сортировки.","О(n)","О(n) - линейное время. Пример: простой поиск(тупой поиск).","О(n^ 2)","О(n^ 2) - квадратичное время. Пример: медленные алгоритмы сортировки."]},{"l":"Бинарный поиск","p":["Бинарный поиск- алгоритм; на входе получает отсортированный список элементов. Если элемент, который вы ищете, присутствует в списке, то алгоритмы возвращает ту позицию, где он находится, в противном случае возвращает тип данных nil."]},{"i":"когда-использовать-бинарный-поиск","l":"Когда использовать бинарный поиск?","p":["Предположим, вы ищете фамилию человека в списке людей. Она начинается с буквы K. Конечно, можно начать с самого начала списка, но это занимает больше времени. Так что для ускорения поиска его можно начинать с середины списка. Ведь буква K должна находиться ближе к середине списка."]},{"i":"как-работает-бинарный-поиск","l":"Как работает бинарный поиск?","p":["Рассмотрим следующий пример: я загадал число от 1 до 100. Вы должны отгадать мое число, использовав меньшее количество поисковых шагов. И при каждом ответе я буду говорить один из трех ответов: мало, много или угадал."]},{"i":"почему-он-лучше-чем-тупой-поиск","l":"Почему он лучше чем тупой поиск?","p":["Предположим, что у нас есть массив из 240 тысяч чисел.","Наихудший случай для тупого поиска будет 239999 попыток.","А вот для бинарного поиска всего лишь 18 попыток, потому что всегда отсекается половина списка."]},{"l":"Сложность алгоритма","p":["В общем случае для списка из n элементов алгоритм будет работать в O(log n) шагов. В то время как тупой поиск будет работать в O(n) шагов."]},{"l":"Реализация бинарного поиска на Go"},{"i":"рекурсия-recursion","l":"Рекурсия (Recursion)","p":["Рекурсия- элегантный способ решения задач. Это метод решения задач, при котором функция вызывает саму себя в процессе выполнения.","Рекурсивные алгоритмы широко используются в программировании для решения задач, которые можно разбить на более простые подзадачи того же типа."]},{"i":"когда-использовать-рекурсию","l":"Когда использовать рекурсию?","p":["Рекурсия полезна, когда задача естественным образом разделяется на аналогичные, но меньшие по размеру подзадачи.","Рекурсия часто применяется:","В деревьях.","В графах.","В сортировках.","В математических вычислениях."]},{"i":"как-работает-рекурсия","l":"Как работает рекурсия?","p":["Рекурсивная функция обычно состоит из двух частей:","Базовый случай– условие, при котором функция прекращает вызывать саму себя и возвращает результат. Это необходимо для предотвращения бесконечной рекурсии.","Рекурсивный случай– часть функции, в которой она вызывает саму себя с измененными аргументами, приближаясь к базовому случаю.","Рассмотрим в качестве примера вычисления факториала числа.","Факториал числа для n обозначается как n! и выглядит как произведение чисел от 1 до n.","Рекурсивное определение факториала для n можно представить следующим образом:","Базовый случай: 0! = 1 или 1! = 1.","Рекурсивный случай: n! = n * (n-1)!","Преимущества:","Упрощает код для задач, которые естественно рекурсивны.","Позволяет легко реализовывать сложные алгоритмы.","Недостатки:","Может привести к большому количеству вызовов функции, что увеличивает расход памяти.","Риск переполнения стека.","Менее эффективна в сравнении с итеративными алгоритмами из-за накладных расходов памяти"]},{"i":"сложность-алгоритма-1","l":"Сложность алгоритма","p":["Сложность рекурсивных алгоритмов зависит от количества рекурсивных вызовов и работы, выполняемой на каждом шаге. Например, для вычисления факториала сложность будет O(n), то есть один раз на каждый шаг производится вычисление n-1-й части факториала."]},{"l":"Реализация рекурсии на Go"},{"i":"принцип-разделяй-и-властвуй","l":"Принцип \"разделяй и властвуй\"","p":["Решение задачи методом разделяй и властвуй состоит из двух частей:","Сначала определяется базовый случай, это должен быть простейший случай из возможных.","Задача делится или сокращается до тех пор, пока не придется выполнить базовый случай.","Предположим есть участок 1680 на 640 и его надо разделить на квадраты с максимальной площадью. Мы сможем получить два квадрата площадью 640 на 640, но у нас останется еще участок 640 на 400, что не является квадратом. Так вот к нему мы можем опять применить принцип разделяй и властвуй.","То есть алгоритм такой:","Площадь 1680 на 640 разделяется на квадраты с максимальной площадью, остается участок 640 на 400.","Площадь 640 на 400 разделяется на квадраты с максимальной площадью, остается участок 400 на 240.","Площадь 400 на 240 разделяется на квадраты с максимальной площадью, остается участок 240 на 160.","Площадь 240 на 160 разделяется на квадраты с максимальной площадью, остается участок 160 на 80.","Площадь 160 на 80 разделяется на квадраты с максимальной площадью. В итоге будет два квадрата с площадью 80 на 80, и лишнего участка не будет.","То есть базовый случай будет 160 кратно 80, а рекурсивный случай будет участок с максимальной площадью.","Стоит отдельно отметить, что скорее это не алгоритм, а подход к решению задачи."]},{"l":"Пара слов о функциональном программировании","p":["В функциональном программирование нету циклов, поэтому вместо нее используют рекурсивные функции.","Пример вычисления суммы элементов массива на Haskell:"]},{"i":"сортировка-выбором-selection-sort","l":"Сортировка выбором (Selection Sort)","p":["Сортировка выбором– это алгоритм сортировки, который работает, находя наименьший элемент в списке и перемещая его в начало. Затем он находит следующий наименьший элемент и перемещает его на вторую позицию, и так далее, пока список не будет отсортирован."]},{"i":"когда-использовать-сортировку-выбором","l":"Когда использовать сортировку выбором?","p":["Если у тебя небольшой список и важна простота реализации, этот метод подойдет. Однако для больших массивов он неэффективен."]},{"i":"как-работает-сортировка-выбором","l":"Как работает сортировка выбором?","p":["Рассмотрим следующий список чисел: [29, 10, 14, 37, 13].","Находим наименьший элемент в списке и перемещаем его в начало списка. -> 10 -> [10, 29, 14, 37, 13].","Находим следующий наименьший элемент и перемещаем его на вторую позицию. -> 13 -> [10, 13, 14, 37, 29].","Находим следующий наименьший элемент и перемещаем его на третью позицию. -> 14 -> [10, 13, 14, 37, 29].","Находим следующий наименьший элемент и перемещаем его на четвертую позицию. -> 29 -> [10, 13, 14, 29, 37]."]},{"i":"сложность-алгоритма-2","l":"Сложность алгоритма","p":["Сложность алгоритма сортировки выбором равна O(n^2)."]},{"l":"Реализация сортировки выбором на Go"},{"i":"сортировка-слиянием-merge-sort","l":"Сортировка слиянием (Merge Sort)","p":["Сортировка слиянием– это алгоритм сортировки, который использует подход «разделяй и властвуй». Он разбивает список на две половины, рекурсивно сортирует каждую половину, а затем объединяет (сливает) их в один отсортированный список."]},{"i":"когда-использовать-сортировку-слиянием","l":"Когда использовать сортировку слиянием?","p":["Сортировка слиянием эффективна для больших массивов, так как её сложность всегда O(n log n), независимо от начального порядка элементов. Она также полезна, когда требуется стабильная сортировка (сохранение порядка равных элементов)."]},{"i":"как-работает-сортировка-слиянием","l":"Как работает сортировка слиянием?","p":["Рассмотрим список чисел: [38, 27, 43, 3, 9, 82, 10].","Алгоритм работает следующим образом:","Разделяем список на две половины: [38, 27, 43, 3] и [9, 82, 10].","Рекурсивно сортируем каждую половину:","Левый список: [3, 27, 38, 43].","Правый список: [9, 10, 82].","Объединяем два отсортированных списка в один: [3, 9, 10, 27, 38, 43, 82]."]},{"i":"сложность-алгоритма-3","l":"Сложность алгоритма","p":["Сложность алгоритма сортировки слиянием равна O(n log n). Также важно, что сложность алгоритма для памяти равна O(n)."]},{"l":"Реализация сортировки слиянием на Go"},{"i":"быстрая-сортировка-quick-sort","l":"Быстрая сортировка (Quick Sort)","p":["Быстрая сортировка– это ещё один алгоритм, использующий подход «разделяй и властвуй». Он выбирает опорный элемент (pivot), разделяет список на две части: элементы меньше опорного и элементы больше опорного, а затем рекурсивно сортирует каждую часть."]},{"i":"когда-использовать-быструю-сортировку","l":"Когда использовать быструю сортировку?","p":["Быстрая сортировка эффективна для больших массивов и обычно работает быстрее, чем сортировка слиянием, на практике. Однако её производительность зависит от выбора опорного элемента. В худшем случае её сложность может достигать O(n^2)."]},{"i":"как-работает-быстрая-сортировка","l":"Как работает быстрая сортировка?","p":["Рассмотрим список чисел: [29, 10, 14, 37, 13].","Выбираем опорный элемент, пусть будет последний элемент 13.","Разделяем список на две части: [29, 14, 37](больше опорного) и [10](меньше опорного).","Рекурсивно сортируем каждую часть: [14, 29, 37](больше опорного) и [10](меньше опорного).","Объединяем результаты и опорный элемент: [10, 13, 14, 29, 37]."]},{"i":"сложность-алгоритма-4","l":"Сложность алгоритма","p":["Сложность алгоритма быстрой сортировки равна O(n log n) в лучшем случае, а в худшем случае – O(n^2). Также важно, что сложность алгоритма для памяти равна O(log n) из-за рекурсии."]},{"l":"Реализация быстрой сортировки на Go"},{"l":"Сравнение алгоритмов сортировки","p":["O(1)","O(log n)","O(n log n)","O(n)","O(n^ 2)","Алгоритм","Быстрая сортировка","Для больших списков, где важна скорость","Для больших списков, где важна стабильность","Для небольших списков, где важна простота реализации","Когда использовать","Лучший случай","Память","Сортировка выбором","Сортировка слиянием","Средний случай","Худший случай"]},{"i":"поиск-в-ширину-breadth-first-search-или-bfs","l":"Поиск в ширину (Breadth-First Search или BFS)","p":["Скоро будет..."]},{"i":"поиск-в-глубину-depth-first-search-или-dfs","l":"Поиск в глубину (Depth-First Search или DFS)","p":["Скоро будет..."]}],[{"l":"Структуры данных"},{"i":"что-такое-структура-данных","l":"Что такое структура данных?","p":["Структура данных- это способ хранения и упорядочения данных в памяти."]},{"i":"как-работает-память","l":"Как работает память?","p":["Перед тем, как пойти дальше, надо понять, что такое память.","Представьте, что вы пришли в театр и хотите оставить свои личные вещи в гардеробе. Для хранения вещей там есть специальные ящики. В каждые такой ящик можно положить только одну вещь. Если вы хотите поместить еще одну вещь, то потребуется два ящика.","По-большей части именно так и работает память в компьютере. Она представляет собой большое множество ящиков, и у каждого ящика есть уникальный номер(адрес).","Каждый раз, когда вы хотите поместить вещь в ящик, вы запрашиваете у компьютера номер ящика, который свободен.","Если же вам надо сохранить несколько вещей это можно сделать двумя основными способами:","Воспользоваться массивами.","Воспользоваться связными списками."]},{"i":"что-такое-стек-и-стек-вызовов","l":"Что такое стек и стек вызовов?","p":["В стек отправляется вызов bye.","В стек отправляется вызов greet.","В стек отправляется вызов greet2.","Вот алгоритм работы стека вызовов для примера выше:","Выводится сообщение \"Goodbye\".","Выводится сообщение \"Hello, $name\".","Выводится сообщение \"How are you, $name\".","Каждый раз когда мы вызываем функцию, она помещается в стек вызовов.","Мы видем что у нас есть функция greet, которая вызывает другие функции и передает им аргументы.","Сначала давайте обратив внимание на пример ниже:","Стек вызовов- это стек, который работает внутри компьютера и хранит все вызовы функций, выполняемых над программой.","Стек- простая структура данных. Про сам стек как про структуру данных будет изложено ниже.","Управление возвращается в функцию greet.","Функция bye убирается из стека вызовов.","Функция greet убирается из стека вызовов.","Функция greet2 убирается из стека вызовов."]},{"l":"Массивы","p":["Иногда в памяти надо сохранить список элементов. Что использоваться для хранения этого списка? Массив или связный список?","Для начала попробуем сохранить данные в массиве.","В массиве данные хранятся непрерывно в памяти компьютера(то есть в соседних ячейках памяти). То есть компьютер будет искать место куда сохранить подряд идущие данные, а если добавить новые данные и следующая ячейка уже занята, то компьютер будет переносить эти данные в новое место, где достаточно места для подряд идущих данных.","В качестве решения проблемы можно заранее выделить определенное количество ячеек памяти. Например, на текущий момент у нас есть в массиве три ячейки, но мы заранее выделели 10 ячеек памяти. Однако это неэффективно, так как нам могут и не понадобиться все эти ячейки, а другие задачи не смогут использовать эти ячейки памяти."]},{"l":"Пример массива на Go","p":["В примерах ниже у нас в массиве три элемента, но заранее выделены 10 ячеек памяти."]},{"l":"Связные списки","p":["Связные списки похожи на массивы, но в них элементы могут размещаться где угодно в памяти. Это благодаря тому, что в связных списках каждый элемент хранит уникальный указатель на следующий элемент. Таким образом набор произвольных адресов памяти объединяется в цепочку. Cледовательно, в памяти ничего не перемещается.","Зачем тогда использовать массивы вместо связных списков?","Работая с связными списками мы не можем получить доступ к конкретному элементу. Нам сначала надо получить первый элемент, а затем его следующий, и так далее пока не найдется требуемый элемент.","А вот в случае с массивами мы можем получить доступ к конкретному элементу просто используя его индекс, так как они идут подряд и мы знаем какой элемент находится в каком месте."]},{"l":"Реализация связного списка на Go"},{"l":"Сравнение массивов и связных списков","p":["Операция","Массивы","Связные списки","Чтение","O(1)","O(n)","Вставка","Удаление","Как же тогда поступить если нам нужен и быстрое чтение, и быстрая вставка/удаление?","Тогда мы можем использовать массив связных списков.","Например, у нас есть база данных имен пользователей. Массив хранит в себе 26 связных списков, где каждый список это имена на определенную букву. В итоге будет и быстрое чтение, и быстрая вставка/удаление."]},{"l":"Бинарное дерево поиска","p":["Бинарное дерево поиска(BST)— это структура данных, где каждый узел имеет не более двух потомков: левый и правый.","Бинарные деревья широко используются:","В базах данных.","В кешах.","В индексах"]},{"i":"как-работает-бинарное-дерево-поиска","l":"Как работает бинарное дерево поиска?","p":["Оно организовано по следующим правилам:","Левый потомок содержит значение меньше, чем у родителя.","Правый потомок содержит значение больше, чем у родителя.","Эти правила применяются рекурсивно ко всем узлам."]},{"l":"Операции над бинарным деревом","p":["Вставка: начинаем с корня дерева, если новое значение меньше текущего узла, идем влево; если больше — направо. Повторяем, пока не найдем свободное место.","Удаление: если у узла нет потомков — просто удаляем его, если у узла один потомок — заменяем узел его потомком, если у узла два потомка — заменяем его на наименьший узел из правого поддерева.","Поиск: сравниваем искомое значение с корнем, если меньше — ищем в левом поддереве, если больше — в правом, а если совпадает — нашли нужный узел.","Обход в порядке: начинаем с корня дерева, если узел меньше текущего — идем вперед, если больше — идем назад.","Операции","Лучший случай","Худший случай","Вставка","O(log n)","O(n)","Удаление","Поиск","Обход"]},{"l":"Реализация бинарного дерева на Go"},{"l":"Стек","p":["Стек— это структура данных, которая работает по принципу LIFO, то есть последний элемент, добавленный в стек, будет первым, который из него удалится. Стек можно представить как стопку тарелок: вы кладете тарелки одну на другую, и чтобы взять тарелку, нужно снять верхнюю.","Стеки широко используются:","В алгоритмах (например, обход графов, проверка сбалансированности скобок).","В управлении вызовами функций (стек вызовов).","В текстовых редакторах (например, для реализации отмены действий)."]},{"i":"как-работает-стек","l":"Как работает стек?","p":["Стек поддерживает две основные операции:","Push— добавление элемента на вершину стека.","Pop— удаление элемента с вершины стека.","Дополнительные операции:","Peek— просмотр элемента на вершине стека без его удаления.","IsEmpty— проверка, пуст ли стек."]},{"l":"Операции над стеком","p":["Операция","Лучший случай","Худший случай","Push","O(1)","Pop","Peek","IsEmpty"]},{"l":"Реализация стека на Go"},{"l":"Хэш-таблицы","p":["Хэш-таблица— это структура данных, которая позволяет хранить пары ключ-значение и обеспечивает быстрый доступ к значению по ключу. Хэш-таблицы широко используются благодаря своей эффективности: в среднем случае операции вставки, поиска и удаления выполняются за время O(1).","Хэш-таблицы применяются:","В базах данных для индексации.","В кэшировании (например, кэш веб-серверов).","В реализации ассоциативных массивов (словарей).","В алгоритмах, где требуется быстрый поиск данных."]},{"i":"как-работает-хэш-таблица","l":"Как работает хэш-таблица?","p":["Хэш-таблица использует хэш-функцию для преобразования ключа в индекс массива. Этот индекс указывает на ячейку, где хранится значение.","Если два ключа имеют одинаковый индекс, то происходит коллизия и используются методы разрешения коллизий, такие как цепочки или открытая адресация."]},{"l":"Операции над хэш-таблицей","p":["O(1)","O(n)","Вставка","Вставка (Insert):","Если в ячейке есть значение, оно возвращается.","Если возникает коллизия, используется метод разрешения коллизий.","Если использовались цепочки, элемент удаляется из списка.","Если ячейка пуста или содержит другой ключ (коллизия), используется метод разрешения коллизий.","Значение сохраняется в соответствующей ячейке.","Значение удаляется из ячейки.","Ключ обрабатывается хэш-функцией, чтобы определить индекс.","Лучший случай","Обновление","Обновление (Update):","Операция","Основные операции хэш-таблицы","Поиск","Поиск (Search):","Поиск элемента по ключу и замена его значения.","Удаление","Удаление (Delete):","Худший случай"]},{"l":"Реализация хэш-таблицы на Go","p":["Мало когда вам придется реализовывать с нуля хэш-таблицу, так как в любом приличном языке программирования уже существует реализация хэш-таблицы. В Go такой структурой является map(словарь).","В качестве хорошей хэш-функции можно использовать SHA из библиотеки crypto/sha256."]},{"l":"Графы"}],[{"l":"Пакет crypto","p":["Пакет crypto предоставляет набор интерфейсов и функций для работы с криптографическими операциями, такими как хеширование, шифрование, цифровые подписи и генерация случайных чисел.","Этот пакет является частью стандартной библиотеки Go и служит основой для более специализированных пакетов, таких как crypto/aes, crypto/md5, crypto/rsa, crypto/sha1, crypto/sha256 и другие."]},{"l":"Основные возможности"},{"l":"Хеширование","p":["Пакет crypto предоставляет функции для работы с хешами SHA-256.","Примеры хеш-функций:","crypto/sha256- SHA-256 (256-битный хэш-функция).","crypto/sha512- SHA-512 (512-битный хэш-функция).","crypto/md5- MD5 (128-битный хэш-функция) - Не рекомендуется использовать в криптографических целях.","Часто используемые функции:","sha256.New()- Создает новый хэшер SHA-256.","sha256.Sum256(data []byte) [32]byte- Рассчитывает SHA-256 хэш данных."]},{"l":"Симметричное шифрование","p":["Пакет crypto предоставляет интерфейсы для работы с симметричными шифрованиями, такие как cipher.Block, cipher.Stream.","Примеры алгоритмов шифрования:","crypto/aes- AES (Advanced Encryption Standard).","crypto/des- DES (Data Encryption Standard) - Устарело.","Часто используемые функции:","aes.NewCipher(key []byte) (cipher.Block, error)- Создает новый блок AES.","cipher.NewCBCEncrypter(block cipher.Block, iv []byte) cipher.BlockMode— создает шифратор в режиме CBC.","cipher.NewCBCDecrypter(block cipher.Block, iv []byte) cipher.BlockMode— создает дешифратор в режиме CBC.","Режим CBC — это шифрование в цикле, которое позволяет использовать блок шифрования для каждого блока данных."]},{"l":"Ассиметричное шифрование","p":["Пакет crypto предоставляет интерфейсы для асимметричного шифрования, такие как crypto.PublicKey и crypto.PrivateKey.","Примеры алгоритмов шифрования:","crypto/rsa- RSA (Rivest–Shamir–Adleman).","crypto/dsa- DSA (Digital Signature Algorithm).","crypto/ecdsa- ECDSA (Elliptic Curve Digital Signature Algorithm).","Часто используемые функции:","rsa.GenerateKey(rand io.Reader, bitSize int) (*rsa.PrivateKey, error)- Создает новый ключ RSA.","rsa.EncryptPKCS1v15(rand io.Reader, pub *rsa.PublicKey, plaintext []byte) ([]byte, error)- Шифрует данные с использованием RSA с использованием PKCS#1.","rsa.DecryptPKCS1v15(rand io.Reader, priv *rsa.PrivateKey, ciphertext []byte) ([]byte, error)- Расшифровывает данные с использованием RSA с использованием PKCS#1."]},{"l":"Цифровые подписи","p":["Пакет crypto предоставляет интерфейсы для создания и проверки цифровых подписей.","Примеры алгоритмов цифровой подписи:","crypto/rsa- RSA (Rivest–Shamir–Adleman).","crypto/ecdsa- ECDSA (Elliptic Curve Digital Signature Algorithm).","Часто используемые функции:","ecdsa.GenerateKey(curve elliptic.Curve, rand io.Reader) (*ecdsa.PrivateKey, error)- Создает новый ключ ECDSA.","ecdsa.Sign(rand io.Reader, priv *ecdsa.PrivateKey, hash []byte) (r, s *big.Int, err error)- Подписывает данные с использованием ECDSA.","ecdsa.Verify(pub *ecdsa.PublicKey, hash []byte, r, s *big.Int) bool- Проверяет подпись ECDSA."]},{"l":"Генерация случайных чисел","p":["Пакет crypto/rand предоставляет криптографически безопасный генератор случайных чисел.","Часто используемые функции:","rand.Read(b []byte)- Создает случайные числа в буфере b.","rand.Intn(n int) int- Возвращает случайное число от 0 до n-1."]},{"l":"Остальные возможности","p":["Поддержка TLS/SSL.","Поддержка X.509 сертификатов.","Поддержка других криптографических стандартов."]}],[{"l":"Генерики в Golang","p":["Функции Go могут быть написаны так, чтобы работать с несколькими типами данных, используя так называемые type parameters или параметры типа. Такой параметр находится в [] перед аргументами функции.","Запись выше означает, что s это срез из любого типа T, который удовлетворяет условию comparable. Это полезное ключевое слово, которые позволяет использовать в качестве аргументов типы, которые поддерживают сравнение при помощи == и !=. То есть функция Index работает для любого типа данных, который можно сравнить.","В добавок к Generic-функциям в Go есть Generic-типы."]}],[{"l":"Интерфейсы в Golang"},{"l":"Интерфейсы","p":["Интерфейс представляет собой набор описаний методов. В качестве значения интерфейса может быть любая реализация всех его методов.","ВАЖНО: В Go нету ключевого слова implements, интерфейс наследуется через реализацию всех его методов.","Под капотом интерфейсы хранят значение и конкретный тип: (value, type).","ВАЖНО: В Go используются пустые интерфейсы interface{}, что помогает принимать неизвестный тип данных."]},{"l":"Проверка типа","p":["Так как тип переменной может быть interface{}, то нам надо проверять тип полученных данных. Делается это при помощи следующей конструкции: t, ok := i.(T). Если условие было выполнено успешно, то мы получим значение и статус true, иначе нулевое значение и статус false.","Проверку типа можно реализовать через switch."]},{"i":"переопределение-string","l":"Переопределение String()","p":["Как и в других языках в Go можно переопределить метод toString. Для этого используется стандартный интерфейс Stringer:","Поэтому можно реализовать следующий функционал."]},{"l":"Обработка ошибок","p":["Программы Go взаимодействуют с ошибками через значение error. Тип данных error такой же встроенный интерфейс как fmt.Stringer.","Функции часто возвращают error как значение, и мы должны проверять является ли ошибка nil или нет.","nil- обозначет успех выполнения, а если наоборот, то провал выполнения."]}],[{"l":"Многопоточность и параллельность в Golang"},{"l":"Горутины","p":["В Go есть горутины- легковесный способ управления рантаймом Go. Горутины запукаются через ключевое слово go. Например, конструкция ниже запустит в горутине функцию f(x,y,z):","ВАЖНО: вычисление f, x, y и z происходит в текущей горутине, а сама функция выполняется в новой горутине.","ВАЖНОx2: горутины работают в одном адресном пространстве, поэтому доступ к памяти должен быть синхронизирован."]},{"l":"Каналы","p":["Channels- типизированные каналы, которые позволяют через оператор -, отправлять и получать данные.","Каналы можно создавать через функцию make, как словари и срезы.","ВАЖНО: по-умолчанию отправка и получения данных блокируется пока вторая сторона не считает данные. Это позволяет синхронизироваться горутинов без явных блокировок.","Каналы могут быть буфферизированы, им можно передать длину буффера.","Отправитель может закрыть канал через ключевое слово close, чтобы дать понять, что данные больше не поступят. Получатель же может проверять был ли канал закрыт:","Также стоит заметить, что через range можно получать данные до тех пор пока канал не будет закрыт.","ВАЖНО: каналы не файлы, обычно их не надо закрывать самому через close, только тогда, когда требуется явно указать на это.","Также в Go есть ключевое слово select, по-факту это switch, но для каналов. select блокируется до тех пор пока один из его случаев не выполнится, если несколько случаем готовы выполниться, то он выполняет случайный."]},{"l":"Mutex","p":["Каналы являются хорошим способом коммуникации между горутинами, но что если нам просто надо убедиться, что доступ к переменной имеет только одна горутина в определенный момент времени. Данный механизм называется mutual exclusion или Mutex.","В Go мы можем использовать Mutex через sync.Mutex и два его метода:","Lock","Unlock"]}],[{"l":"Основы Golang"},{"i":"пакеты-переменные-и-функции","l":"Пакеты, переменные и функции"},{"l":"Пакеты","p":["Каждая Go программа состоит из пакетов и стартует с пакета main. Программа ниже использует пакеты fmt и math/rand.","В соглашении по коду сказано, что имя пакета должно быть таким же как последний элемент пути импорта. То есть файлы в math/rand должны начинаться с package rand."]},{"l":"Импорты","p":["Код ниже группирует несколько импортов через \"факторизированный\" (от слова Factory) способ.","Однако ничего нам не мешает использовать несколько операторов import.","Однако хорошим тоном считается использование \"факторизированного\" метода."]},{"l":"Экспортированные имена","p":["В Go важно соблюдать наименование объектов, так как экспортируются лишь те объекты, что начинаются на заглавную букву.","Верно:","Неверно, вызовит ошибку:"]},{"l":"Функции","p":["В Go функции могут принимать ноль или несколько элементов. В примере ниже функция add принимает два параметра типа int и возвращает результат того же типа.","ВАЖНО: тип идет после объявления переменной/функции.","Когда два или больше параметров именованной функции имеют одинаковый тип, мы можем указать тип только для последнего параметра.","Также функция может возвращать несколько результатов."]},{"l":"Именнованные значение возврата","p":["Результат любой функции может быть наименован. Они будут рассматриваться как переменные объявленные на верхнем уровне функции.","Благодаря этому имеется возможность использовать return без значений, тогда функция вернет именнованные параметры."]},{"l":"Переменные","p":["В Go есть оператор var, который позволяет создать переменную. С данным операторм работают те же правила, что и с аргументами функций.","В отличии от других языков программирования здесь Go не упадет с ошибкой, что значение не иницилизировано. Go автоматически задает переменным значения по-умолчанию(нулевые значения): 0, false и другие.","Объявление переменных может включать инициализацию, одну для каждой переменной. Если инициализация используется, то можно опустить тип данных, он будет подобран по указанному значению.","Если инициализация переменных происходит внутри функций, то можно использовать сокращенный оператор :=, который заменяет var и указания типа."]},{"l":"Базовые типы данных","p":["В Go имеются следующие базовые типы данных:","bool","string","int, int8, int16, int32, int64","uint, uint8, uint16, uint32, uint64, uintptr","byte // тоже самое, что и uint8","rune // тоже самое, что и int32, представляет собой Unicode.","float32, float64","complex64, complex128","Ниже приведен пример использования некоторых типов данных, также ниже приведен способ \"факторизированной\" группировки. Также стоит заметить, что int, uint и uintptr имеют привязку либо к 32, либо к 64 битам в зависимости от архитектуры процессора."]},{"l":"Преобразование типов","p":["В Go есть выражение T(v), которые приобазует значение v в тип T.","Например:","Или:","В отличии от C, в Go приобразование между разными типами данных требует явного преобразования. Вы не сможете использовать int в качестве float64 без преобразования."]},{"l":"Константы","p":["Константы объявляются также как и переменные, но с ключевым словом const.","Константы могут быть:","символами","строками","логическим значением","цифровым значением","Константы не могут быть объявлены с использованием :=."]},{"i":"операторы-управления-потоком-for-if-else-switch-и-defer","l":"Операторы управления потоком: for, if, else, switch и defer"},{"l":"For","p":["Go имеет всего одну конструкцию для построения циклов - for. Данный цикл имеет три части, которые разделены ;:","состояние инициализации, выполняется при первой итерации;","условие: проверяется на соответствие перед каждой итерацией;","пост-условие: выполняется после конца каждой итерации.","Состояние инициализации часто будет просто кратким объявлением переменной, и эта переменная будет видна только внутри цикла.","Цикл прекратит свою работу, когда условие будет ложным.","ВАЖНО: В отличии от других языков в Go не нужен () вокруг трех компонентов.","Состояние инициализации и пост-условие могут быть опциональными(цикл будет работать как while в других ЯП):","Можно такде отбросить и условие, тогда это будет бесконечный цикл.","Также стоит упомянуть, что Go поддерживает break и continue."]},{"l":"If","p":["Также как в случае с циклами в Go не надо использовать () для условий. Но {} обязательны, невозможно сделать условие в одну строку.","if можно использовать прямо вместе с инициализацией переменной:","Стоит отметить, что переменная v не будет доступна извне тела if."]},{"i":"ifelse","l":"If..else","p":["Переменная v из примера выше распространяется и на телов условия else.","Можно использовать промежуточные условия else if."]},{"l":"Switch","p":["switch это более короткий способ записать последовательность из if..else условий. У конструкции есть условия, и если оно совпадет со значением, то выполнится код, который содержится в этому условии. А если ни одно условие не будет соответствовать правде, то выполнится финальный default.","Можно вызвать switch без условия, оно будет соответствовать switch true:"]},{"l":"Defer","p":["Оператор defer откладывает выполнения функции пока не будет произведен return.","Стоит отметить, что аргументы поступают в функцию сразу, но выполняется они лишь перед return.","ВАЖНО: функции, которые вызываются с defer помещаются в стек, а после перед return выполняются по принципе LIFO(Last-In-First-Out)."]},{"l":"Продвинутые типы данных"},{"l":"Указатели","p":["В языке Go присутствуют указатели. Указатель содержит адрес памяти значения.","Тип *T- это указатель для значения T. Значение указатель по-умолчанию nil.","Оператор генерирует указатель на операнд.","Оператор * обозначет значение, которое хранится по указателю.","ВАЖНО: в Go в отличии от C нету арифметики для указателей."]},{"l":"Структуры","p":["Структура - это коллекция полей. В Go используется ключевое слово struct.","Через оператор . можно обращаться к полям структуры.","Точно также можно использовать указатель на структуры.","Структуру можно инициализировать несколькими способами."]},{"l":"Массивы","p":["В Go массив обозначается как [n]T, что означет массив из T размерности n.","Размерность - это часть типа, поэтому массивы не могут быть изменены в размере. Но это не проблема, о чем ниже.","Также массиву можно задать размер, которые автоматически подберется в соответствии с количеством элементов.","В Go символ ... используется для указания множества. Ниже будет несколько вариантов использования данного оператора."]},{"l":"Срезы","p":["Массив в Go имеет фиксированный размер, но в Go есть срез, который имеет динамический размер. Размер будет зависеть от текущего количества элементов. В практике срезы встречаются чаще, чем массивы.","Срез обозначается типом []T, что обозначет срез с данными типа T. Срез формируется путем указание двух границ, при этом стоит иметь ввиду, что первый включается, последний исключается.","ВАЖНО: Стоит иметь ввиду, что срезы не хранят данные, они лишь описывают секции массивов. Если вы поменяете элемент в срезе, он поменяется и в массиве.","Также если мы имеем массив [10]int, то следующие срезы одинаковые:","[0:10]","[:10]","[0:]","[:]","У среза есть такие параметры как: длина и емкость. Длина- количество элементов, который он содержит. Емкость- количество элементов в базовом массиве.","Нулевое значение для срезов это nil.","Срезы могут быть созданы через встроенную функцию make.","Обычно, чтобы добавить новые элементы в срез в Go используется функция append. Выглядит она следующим образом: func append(s []T, vs ...T) []T.","Первый параметры это срез, к которому мы хотим добавить элементы, а дальше сами элементы(их перечисление). Результат функции это все элементы оригинального среза + новые.","Если в массиве не хватает места, чтобы добавить элементы в срез, то будет создан массив с большей вместимостью.","Также в append можно передать массив элементов и декомпозировать его при помощи ...."]},{"l":"Range","p":["range позволяет итерировать некоторые объекты, возвращая на каждой итерации два значения: индекс и значение элемента. Также range можно использовать как итератор в цикле for.","При использовании range можно опустить одно из значений."]},{"i":"словаримапы","l":"Словари(мапы)","p":["Словарь позволяет хранить данные в виде ключ-значение. Нулевое значение - nil, для нулевого словаря не заданы ключи, а также ключи не могут быть добавлены.","Словарь можно создать при помощи функции make.","Также если тип верхнего-уровня представляет собой просто наименование, то его можно опустить.","Теперь затронем изменения словарей. Чтобы добавить или обновить элемент в словаре, нужно обратиться к нему по ключу.","Чтобы получить элемент:","Чтобы удалить элемент используется функция delete, которая принимает словарь и ключ, по которому нужно произвести удаление.","Можно проверить существует ли элемент по ключу при помощи следующей конструкции:"]},{"l":"Функции как тип данных","p":["В Go функции тоже переменные. И соответственно они могут использоваться там же, где и другие переменные. Функции могут быть аргументами других функций или значениями возврата.","Также Go поддерживает в качестве последнего аргумента функции бесконечное множество параметров."]},{"l":"Методы","p":["В Go нету классов. Однако, вы можете создавать методы для типов. Метод это функция, которая имеет специальный receiver аргумент. Он задается между func и именем метода.","ВАЖНО: метод все та же функция, но с использованием receiver. Вы можете заменить ее на обычную функцию, но она не будет привязана к типу.","Методы можно создавать для любых типов данных(не только структур).","Если в методе надо изменить значение receiver, то используются указатели.","ВАЖНО: стоит иметь ввиду, что v.Scale(10) это по-сути (v).Scale(10). А также если аргумент метода или функции у нас это указатель, то и передать мы должны его с символом ."]}],[{"l":"Git"},{"l":"Установка git","p":["Git можно установить либо из официального репозитория:","Либо из исходников:"]},{"l":"Настройка git","p":["Настройка git происходит через git config."]},{"l":"Хранения настроек","p":["Настройки могут храниться в трех местах:","/etc/gitconfig, если использовать git config --system;","~/.gitconfig если использовать git config --global;",".git/config если использовать git config --local.","Чтобы просмотреть все существующие настройки:"]},{"i":"username-и-useremail","l":"user.name и user.email","p":["Первое, что следует настроить эту имя и почту пользователя. Например:"]},{"i":"coreeditor","l":"core.editor","p":["Git нам позволяет явно указать редактор, который стоит использовать для коммитов, разрешения конфликтов и так далее. По-умолчанию значение считывается из переменной среды $EDITOR."]},{"i":"committemplate","l":"commit.template","p":["Позволяет задать шаблон для коммита."]},{"i":"corepager","l":"core.pager","p":["Определяет какая программа будет использована для разбиения текста на страницы."]},{"i":"mergetool","l":"merge.tool","p":["Указывает на инструмент, который надо использовать для команды mergetool."]},{"i":"diffexternal","l":"diff.external","p":["Указывает на инструмент, который надо использовать для сравнения."]},{"i":"initdefaultbranch","l":"init.defaultBranch","p":["Ветка, с которой проект создается по-умолчанию."]},{"i":"pullrebase","l":"pull.rebase","p":["Какое поведение git использовать при получении изменений."]},{"i":"alias","l":"alias.*","p":["Git позволяет создавать псевдонимы. Например:","Советуется добавить:"]},{"i":"coreexcludesfile","l":"core.excludesfile","p":["Какие файлы стоит игнорировать в проектах."]},{"i":"colorui","l":"color.ui","p":["Стоит ли подсвечивать большую часть вывода.","Можно отдельно для разных элементов: color.branch, color.diff, color.interactive, color.status."]},{"l":"Команды git"},{"l":"git help","p":["Выводит справочную информацию о той или иной команде."]},{"l":"git config","p":["Позволяет взаимодействовать с конфигурацией git."]},{"l":"git init","p":["Инициализирует новый проект."]},{"l":"git add","p":["Индексирует указанные файлы."]},{"l":"git commit","p":["Делает коммит с проиндексированными файлами."]},{"l":"git clone","p":["Клонирует существующий репозиторий."]},{"l":"git status","p":["Позволяет просматривать состояние файлов(Untracked, Unmodified, Modified, Staged)."]},{"l":"git diff","p":["Позволяет просматривать отдельные файлы на изменение содержимого."]},{"l":"git rm","p":["Удаление файла из индексации репозитория."]},{"l":"git mv","p":["Команда чтобы переименовать файл.","Является alias для команд ниже:"]},{"l":"git log","p":["Позволяет просматривать историю коммитов."]},{"i":"git-restore--git-reset","l":"git restore / git reset","p":["git restore это современная замена git reset.","Отменяет индексацию файла."]},{"l":"git remote","p":["Позволяет взаимодействовать с удаленными репозиториями."]},{"l":"git fetch","p":["Позволяет подгрузить изменение с определенного удаленного репозитория."]},{"l":"git pull","p":["Тот же git fetch, но для основного сервера, как правило, и более прост в использовании."]},{"l":"git push","p":["Отправка изменений в удаленный репозиторий."]},{"l":"git tag","p":["Позволяет задавать теги.","Теги нужно отдельно отправлять в удаленный репозиторий. Смотрите команду git push.","Также обратите внимание на удаление тега на удаленном репозитории, также через команду git push."]},{"l":"git show","p":["Позволяет просматривать информацию о файлах, деревьях, тегах и коммитах."]},{"l":"git checkout","p":["Позволяет переключаться между ветками."]},{"l":"git branch","p":["Позволяет создать новую ветку.","Новую ветку, созданную командой git branch --move, надо отправить в удаленный репозиторий."]},{"l":"git merge","p":["Позволяет провести слияние веток.","Иногда Git не может сам решить конфликты, и оставляет маркеры для того, чтобы их можно было разрешить вручную.","Пример:","В этом примере произошел конфликт текущей ветки с веткой iss53 в файле index.html."]},{"l":"git mergetool","p":["Открывает инструмент для разрешения конфликтов."]},{"l":"git ls-remote","p":["Позволяет просмотреть все удаленный ссылки в удаленном репозитории."]},{"l":"git rebase","p":["Накладывает все коммиты одной ветки поверх коммитов другой ветки."]},{"l":"git daemon","p":["Используется для настройки демона Git.","Флаги:","reuseaddr: перезапускает сервер без ожидания таймаута существующих подключений.","base-path: указывается путь, где хранятся проекты. Путь будет автоматически подставляться, то есть вместо /srv/git/nvops.git можно будет использовать nvops.git.","export-all: экспортирует все проекты в директории /srv/git/.","P.S: base-path влияет на git://.","P.P.S: вместо export-all можно добавлять в каждый репозиторий файл git-daemon-export-ok.","Однако команду выше стоит запускать через сервис. Как это делать можно посмотреть в пункте серверный git."]},{"l":"git instaweb","p":["Позволяет запустить веб-сервер для просмотра экземпляра GitWeb для текущего репозитория."]},{"l":"git reflog","p":["Позволяет просматривать журнул с привязкой к ссылкам:"]},{"l":"git stash","p":["Позволяет сохранить работу для того, чтобы вернуться к ней позже:"]},{"l":"git clean","p":["Удаляет непроиндексированные файлы:"]},{"l":"git grep","p":["Аналог grep, но для рабочего пространства git и поиска по его деревьям:"]},{"l":"git filter-branch","p":["Является сторонней утилитой - https://github.com/newren/git-filter-repo.","Используется для изменения истории коммитов."]}],[{"l":"SSH"},{"l":"Генерация ssh-ключей"},{"l":"Подключение по SSH"},{"l":"SSH-agent","p":["ssh-agent - менеджер ключей для SSH. Он хранит ваши ключи и сертификаты в памяти, незашифрованные и готовые к использованию ssh. Это избавляет вас от необходимости вводить пароль каждый раз, когда вы подключаетесь к серверу. Он работает в фоновом режиме в вашей системе, отдельно от ssh, и обычно запускается при первом запуске ssh.","Чтобы добавить пароль от приватного ключа:"]},{"l":"SSH-copy-id","p":["Чтобы скопировать ключ на сервер используем комманду ниже:","Не забываем про выдачу необходимых прав."]},{"l":"sshd_config"},{"l":"Лучшие практики","p":["Меняем порт с 22 на любой другой","PermitRootLogin no","PubkeyAuthentication yes","PasswordAuthencication no (исключительно после настройки ключей)","PermitEmptyPasswords no (не имеет смысла, если соблюдать 4 пункт)"]},{"l":"Настройки клиента","p":["Клиент SSH настраивается через файл ~/.ssh/config.","Пример настроек:","Далее делается подключение через команду ниже:"]},{"l":"Пробрасывание портов","p":["Командой выше мы создали подключение через SSH-туннель, с пробросом внешнего 8000 порта на локальный 9000 порт. И после этого НЕ ЗАКРЫВАЯ соединения, в другой вкладке терминала мы сможет обращаться по этому порту."]},{"l":"Моя конфигурация клиента SSH","p":["Ниже расположен пример моей конфигурации Linux"]}],[{"l":"Обоснование требований к программной системе"},{"i":"определение-требований-к-по-виды-требований-этапы-их-разработки","l":"Определение \"требований к ПО\". Виды требований, этапы их разработки","p":["Требования к программному обеспечению— это описание функций, характеристик, ограничений и условий, которым должна соответствовать система для удовлетворения потребностей и ожиданий заинтересованных сторон. Требования определяют, \"что\" система должна делать и \"как\" она должна это делать."]},{"l":"Виды требований","p":["Бизнес-требования: цели и задачи бизнеса, которые проект должен выполнить. Пример: \"Увеличить продажи на 20% за счет внедрения онлайн-магазина\".","Пользовательские требования: описывают задачи, которые пользователь выполняет с системой. Пример: \"Пользователь должен иметь возможность зарегистрироваться и авторизоваться\".","Функциональные требования: описывают конкретные функции системы. Пример: \"Система должна отправлять уведомление пользователю по электронной почте\".","Нефункциональные требования: касаются качественных характеристик системы, таких как производительность, безопасность, масштабируемость.","Системные требования: специфицируют технические параметры системы, такие как поддерживаемые платформы, объем памяти, требования к оборудованию."]},{"l":"Этапы их разработки","p":["Сбор информации: использование интервью, опросов, наблюдений, анализа документов для выявления требований.","Анализ требований: выявление противоречий, пропусков, дублирующих требований.","Документирование: формализация требований в виде спецификаций (SRS — Software Requirements Specification).","Валидация и согласование: проверка требований на соответствие ожиданиям клиента и технической реализуемости.","Управление изменениями: отслеживание и корректировка требований на протяжении жизненного цикла проекта."]},{"l":"Бизнес-требования. Модели анализа бизнеса. Методологии и нотации","p":["Бизнес-требования описывают цели проекта с точки зрения компании и объясняют, зачем проект вообще нужен. Это наиболее высокоуровневые требования, например: \"Снизить расходы на обслуживание клиентов на 15%\", \"Запустить мобильное приложение для увеличения вовлеченности пользователей\"."]},{"l":"Модели анализа бизнеса","p":["SWOT-анализ: определение сильных (Strengths) и слабых (Weaknesses) сторон, возможностей (Opportunities) и угроз (Threats) для бизнеса.","PESTLE-анализ: анализ политических, экономических, социальных, технологических, юридических и экологических факторов, влияющих на проект.","BPMN (Business Process Model and Notation): нотация для моделирования бизнес-процессов, позволяющая визуально представить процессы.","Диаграмма потоков данных (DFD): модель, описывающая, как данные движутся между различными элементами системы."]},{"l":"Методологии и нотации","p":["Методологии:","Agile","Scrum","Waterfall","Kanban.","Нотации:","UML (Unified Modeling Language)","BPMN","IDEF0."]},{"l":"Пользовательские требования. Модели анализа пользовательских требований. Пользовательские истории и варианты использования","p":["Пользовательские требования— это описание действий, которые пользователь хочет выполнять с системой. Пример: \"Пользователь должен иметь возможность загрузить файл\"."]},{"l":"Модели анализа пользовательских требований","p":["Customer Journey Map: визуализация пути пользователя от начала взаимодействия с системой до достижения цели.","Диаграммы вариантов использования: показывают взаимодействие пользователя с системой через различные сценарии."]},{"l":"Пользовательские истории","p":["Как [роль], я хочу [цель], чтобы [результат].","Пример: \"Как зарегистрированный пользователь, я хочу иметь возможность изменить пароль, чтобы защитить свой аккаунт\"."]},{"l":"Варианты использования","p":["Описывают конкретный сценарий взаимодействия пользователя с системой, например: \"Добавление товара в корзину\"."]},{"l":"Управление требованиями. Отслеживаемость требований","p":["Управление требованиями включает в себя выявление, документирование, отслеживание, анализ и контроль изменений требований на протяжении всего жизненного цикла проекта. Это важно для согласования работы команды и обеспечения качества продукта.","Отслеживаемость требований- это способность связывать требования с другими элементами проекта, такими как тестовые сценарии, код, задачи. Используются:","Матрицы отслеживаемости требований.","Инструменты управления требованиями: Jira, Confluence, IBM DOORS."]},{"l":"Выгоды от высококачественного процесса разработки требований","p":["Снижение числа ошибок: Четко сформулированные требования минимизируют недоразумения.","Сокращение времени на разработку: Ясные требования позволяют команде работать эффективнее.","Экономия ресурсов: Снижение затрат за счет предотвращения переработок.","Повышение качества продукта: Продукт будет соответствовать ожиданиям клиента.","Улучшение коммуникации: Формализация требований способствует лучшему взаимодействию между заинтересованными сторонами."]},{"l":"Требования с точки зрения клиента","p":["С точки зрения клиента, требования — это описание того, что они хотят получить от системы. Для клиента важны:","Удобство использования.","Соответствие их бизнес-целям.","Минимизация затрат и времени на внедрение.","Поддержка и развитие системы."]},{"l":"Проблемы при формировании требований","p":["Неясные или расплывчатые требования: Клиенты не всегда точно знают, чего хотят.","Частые изменения требований: Вносятся новые требования по мере разработки.","Конфликты между стейкхолдерами: Разные заинтересованные стороны имеют разные приоритеты.","Нехватка времени и ресурсов: На сбор и анализ требований не выделено достаточно времени.","Плохая коммуникация: Недостаток обратной связи между клиентами и командой."]},{"l":"Разрыв ожиданий. Уменьшение разрыва ожиданий","p":["Разрыв ожиданий возникает, когда конечный продукт не соответствует ожиданиям клиента.","Способы уменьшения разрыва ожиданий:","Постоянная обратная связь с клиентом.","Создание прототипов и демонстрация на ранних стадиях.","Использование Agile для итеративной разработки.","Четкая и прозрачная коммуникация."]},{"l":"Заинтересованные лица","p":["Заинтересованные лица (стейкхолдеры)— это все, кто так или иначе влияет на проект или затрагивается его результатами. Они делятся на:","Внутренние: команда разработки, менеджеры, владельцы бизнеса.","Внешние: заказчики, конечные пользователи, регуляторы.","Для успешного взаимодействия со стейкхолдерами важно:","Идентифицировать ключевых участников.","Понять их ожидания и потребности.","Установить каналы коммуникации."]},{"i":"типовое-по---кто-представляет-интересы-клиентов","l":"Типовое ПО - кто представляет интересы клиентов","p":["Для типового программного обеспечения (например, офисные приложения, CRM-системы) интересы клиентов представляют:","Бизнес-аналитики: выявляют и анализируют потребности широкого круга пользователей.","Продукт-менеджеры: определяют функциональность продукта и стратегию его развития.","Тестировщики и UX-дизайнеры: обеспечивают удобство и качество использования."]},{"l":"Сотрудничество клиентов и разработчиков","p":["Эффективное сотрудничество клиентов и разработчиков включает:","Постоянные встречи и обсуждения (Sprint Review, Demo).","Использование общих инструментов для управления требованиями (например, Jira).","Обратную связь на всех этапах проекта."]},{"l":"Права и обязанности клиентов и разработчиков"},{"l":"Права клиента","p":["Получать информацию о ходе разработки.","Вносить изменения в требования (в рамках договорённостей).","Получать качественный продукт."]},{"l":"Обязанности клиента","p":["Своевременно предоставлять информацию.","Участвовать в согласовании требований."]},{"l":"Права разработчика","p":["Получать четкие и понятные требования.","Ожидать обратную связь от клиента."]},{"l":"Обязанности разработчика","p":["Следовать утверждённым требованиям.","Обеспечивать качество продукта."]},{"l":"Достижение соглашения о требованиях. Базовое соглашение о требованиях","p":["Соглашение о требованиях— это процесс достижения согласия между всеми заинтересованными сторонами относительно целей и содержания проекта.","Этапы:","Обсуждение требований с клиентом.","Создание спецификации (SRS).","Согласование и утверждение документа."]},{"l":"Базовое соглашение о требованиях","p":["Базовое соглашение о требованиях (Baseline Requirements Agreement)— это зафиксированный и утвержденный набор требований, согласованный между всеми заинтересованными сторонами. Это документ, который используется как основа для дальнейшей работы над проектом.","Включает в себя:","Функциональные и нефункциональные требования","Границы системы","Сроки выполнения","Ответственность сторон"]},{"l":"Отбор пользователей для выявления требований. Признаки классификации пользователей","p":["Отбор пользователей включает в себя выбор представителей целевой аудитории.","Признаки классификации пользователей:","Роль в системе (администратор, пользователь).","Частота использования системы.","Уровень технической подготовки."]},{"l":"Способы определения классов пользователей. Архетипы пользователей","p":["Классы пользователей определяются на основе:","Интервью с пользователями.","Анализа демографических данных.","Построения архетипов — обобщённых образов типичных пользователей."]},{"l":"Архетипы пользователей","p":["Новичок: требует интуитивный интерфейс, обучающие материалы или пошаговые инструкции","Продвинутый пользователь: хорошо знаком с системой и требует дополнительных возможностей для настройки и автоматизации.","Скептик: относится к системе с недоверием или сопротивлением к изменениям","Эксперт: имеет глубокие знания в своей функции, знает какие функци ему необходимы","Ценитель удобства: интересуется простотой и экономией времени","Бюджетно-ориентированный пользователь: интересуется соотношением цени и качества","Руководитель: интересуется общей картиной"]},{"i":"методы-выявления-требований-интервью-семинары-фокус-группы-наблюдение-опросные-листы","l":"Методы выявления требований: интервью, семинары, фокус-группы, наблюдение, опросные листы","p":["Интервью: личные беседы с пользователями для выявления их потребностей.","Семинары: коллективные обсуждения для генерации идей.","Фокус-группы: обсуждения с представителями целевой аудитории.","Наблюдение: изучение работы пользователей в их среде.","Опросные листы: сбор мнений через анкеты."]},{"l":"Стадии выявления требований в проекте. Правила сбора информации"},{"l":"Стадии выявления требований","p":["Анализ требований:","Валидация требований:","Выявляются скрытые или неявные требования.","Документирование:","Инициация проекта:","Используются методы, такие как интервью, опросы, наблюдение, анализ документации, фокус-группы.","Определяются основные цели проекта, ключевые заинтересованные стороны и их ожидания.","Отслеживание и контроль изменений требований на протяжении жизненного цикла проекта.","Оформление требований в виде спецификации (например, SRS), диаграмм, моделей.","Проверка требований на полноту, противоречивость, реалистичность и соответствие целям проекта.","Проверка требований на согласованность с ожиданиями клиента.","Проводятся предварительные встречи и обсуждения.","Сбор требований:","Создаются описания бизнес-процессов, диаграммы потоков данных, сценарии использования.","Управление изменениями:","Утверждение требований всеми заинтересованными сторонами.","Формируются черновые описания требований."]},{"l":"Правила сбора информации","p":["Задавайте открытые вопросы для получения развернутых ответов.","Уточняйте, если информация неполная или противоречивая.","Привлекайте всех ключевых стейкхолдеров для полноты картины.","Избегайте предположений — проверяйте каждую гипотезу.","Используйте визуализацию (диаграммы, схемы) для лучшего понимания.","Проводите итерации, возвращаясь к клиенту для уточнений."]},{"l":"Ограничения","p":["Ограничения— это факторы, которые могут ограничивать процесс разработки, внедрения или эксплуатации системы."]},{"l":"Примеры ограничений","p":["Бизнес-ограничения:","Бюджет проекта.","Лицензирование и авторские права.","Недостаток компетенций.","Ограниченное число сотрудников в команде.","Организационные:","Поддержка определенных платформ или браузеров.","Приоритеты бизнеса.","Совместимость с существующими системами.","Соответствие законодательству (например, GDPR).","Социальные и культурные:","Сроки выполнения.","Технические:","Требования к оборудованию (память, процессоры, хранилище).","Учет языков и культурных особенностей пользователей.","Юридические и нормативные:"]},{"l":"Зачем учитывать ограничения","p":["Учет ограничений помогает избежать перерасхода ресурсов, срывов сроков и неудач в проекте."]},{"l":"Подразумеваемые и неявные требования","p":["Подразумеваемые требования— это те, которые очевидны и ожидаются пользователем, но могут быть не задокументированы. Например:","Удобство интерфейса.","Высокая производительность.","Неявные требования— это требования, которые клиент сам не осознает или не формулирует, но они важны для успешного использования системы. Например:","Система должна быть интуитивно понятной.","Обеспечение безопасности данных.","Различие:","Подразумеваемые требования основываются на индустриальных стандартах и ожиданиях.","Неявные требования требуют выявления через наблюдение, анализ поведения пользователей и уточняющие вопросы."]},{"l":"Поиск упущенных требований","p":["Упущенные требования— это те, которые не были выявлены на этапе сбора, но могут оказать значительное влияние на продукт.","Методы поиска упущенных требований:","Анализ аналогичных проектов: Изучите требования других систем в той же отрасли.","Создание прототипов: Прототипирование выявляет дополнительные нужды, которые не были сформулированы ранее.","Обратная связь: Сбор отзывов от пользователей, тестировщиков, разработчиков.","Сценарный анализ: Опишите всевозможные сценарии использования системы и проверьте, покрываются ли они требованиями.","Мозговой штурм: Организуйте встречи команды для выявления дополнительных требований."]},{"l":"Стандарты и методологии разработки требований"},{"l":"Стандарты","p":["IEEE 830-1998: Описывает структуру документа спецификации требований (SRS).","ISO/IEC 29148: Стандарт для управления требованиями.","BABOK (Business Analysis Body of Knowledge): Рекомендации для бизнес-анализа."]},{"l":"Методологии","p":["Agile:","Инкрементальная и итеративная разработка.","Требования описываются в формате user stories.","Scrum:","Планирование спринтов с четкими задачами.","Постоянная работа с бэклогом.","Waterfall:","Последовательный подход, где требования фиксируются на ранних стадиях.","Lean:","Минимизация потерь и фокус на ценности для клиента."]},{"l":"Основные артефакты анализа. Модели анализа бизнеса"},{"l":"Основные артефакты анализа","p":["Спецификация требований (SRS): Документ, детализирующий все требования.","Диаграммы бизнес-процессов: Используются для анализа текущих и будущих процессов.","Матрица отслеживаемости: Помогает отслеживать связь требований с другими элементами проекта.","Прототипы: Визуальное представление системы для согласования с клиентом."]},{"i":"модели-анализа-бизнеса-1","l":"Модели анализа бизнеса","p":["BPMN (Business Process Model and Notation): Показывает процессы в виде блок-схем.","SWOT-анализ: Выявляет сильные и слабые стороны бизнеса.","Диаграммы потоков данных (DFD): Отображают движение данных в системе."]},{"l":"Модели анализа требований. Подходы к моделированию"},{"l":"Модели анализа требований","p":["Use Case Diagram (Диаграммы вариантов использования): Показывают взаимодействие пользователей с системой.","ERD (Диаграммы сущность-связь): Описывают данные и их связи.","State Diagrams (Диаграммы состояний): Описывают поведение системы в различных состояниях."]},{"l":"Подходы к моделированию","p":["Графический: Использование диаграмм (UML, BPMN) для наглядности.","Текстовый: Формальное описание в виде документов.","Прототипирование: Создание интерактивных прототипов системы."]},{"l":"Пользовательские требования. Варианты использования и сценарии использования. Пользовательские истории","p":["Пользовательские требования— это описание задач, которые пользователь хочет выполнить с системой. Пример: \"Пользователь должен иметь возможность оплатить покупку онлайн\".","Варианты использования: Описывают, как пользователь взаимодействует с системой для достижения цели. Пример: \"Авторизация пользователя\" включает сценарии входа с верными и неверными данными.","Сценарии использования: Подробное описание последовательности шагов в рамках варианта использования. Пример: Шаги авторизации пользователя:","Пользователь вводит логин и пароль.","Система проверяет данные.","В случае успеха пользователь попадает в личный кабинет.","Пользовательские истории: Краткий формат требований: \"Как [роль], я хочу [цель], чтобы [результат]\". Пример: \"Как пользователь, я хочу получать уведомления о скидках, чтобы не пропускать акции\".","Отличие Use Case от User Story:","Use Case детализирован и формализован.","User Story проще и используется в гибких методологиях."]},{"i":"определение-анализ-и-проверка-вариантов-использования-варианты-использования-и-функциональные-требования","l":"Определение, анализ и проверка вариантов использования. Варианты использования и функциональные требования","p":["Определение вариантов использования (Use Cases): Варианты использования описывают взаимодействие пользователя с системой для достижения определенной цели. Они формируют мост между пользовательскими и функциональными требованиями."]},{"l":"Этапы работы с вариантами использования","p":["Определение:","Определите роли (актеров), которые взаимодействуют с системой.","Опишите цели, которые каждый актер пытается достичь.","Анализ:","Декомпозируйте варианты использования на шаги.","Уточните возможные альтернативные пути (например, ошибки или исключения).","Проверка:","Убедитесь, что варианты использования покрывают все пользовательские сценарии.","Проверяйте на непротиворечивость и соответствие требованиям."]},{"l":"Связь с функциональными требованиями","p":["Функциональные требования описывают поведение системы в терминах, основанных на вариантах использования. Например:","Вариант использования: \"Пользователь авторизуется в системе\".","Функциональное требование: \"Система должна отправлять код подтверждения при входе\"."]},{"i":"преимущества-требований-основанных-на-вариантах-использования","l":"Преимущества требований, основанных на вариантах использования","p":["Понятность для стейкхолдеров: Описание в терминах сценариев взаимодействия облегчает понимание клиентам.","Обеспечение полноты: Позволяют охватить все возможные сценарии и исключения.","Поддержка тестирования: Варианты использования легко преобразуются в тестовые сценарии.","Улучшение коммуникации: Сценарии взаимодействия создают единый язык для команды разработки и клиентов.","Гибкость: Подход можно адаптировать для Agile или Waterfall."]},{"l":"Функциональные требования. Модели анализа функциональных требований. Методологии и нотации","p":["Функциональные требования— это описание функций, которые система должна выполнять. Они фокусируются на том, что система должна делать.","Примеры:","Система должна позволять пользователю регистрироваться.","При добавлении товара в корзину его количество должно увеличиваться на единицу."]},{"l":"Модели анализа функциональных требований","p":["Диаграммы вариантов использования (Use Case Diagrams): Показывают взаимодействие пользователей с системой.","DFD (Диаграммы потоков данных): Описывают, как данные проходят через систему.","Диаграммы последовательности (Sequence Diagrams): Показывают последовательность взаимодействий."]},{"i":"методологии-и-нотации-1","l":"Методологии и нотации:","p":["Методологии: Agile, Scrum, Waterfall.","Нотации: UML, BPMN, IDEF0."]},{"l":"Бизнес-правила и их роль в требованиях. Выявление бизнес-правил","p":["Бизнес-правила— это ограничения, правила или условия, которые определяют поведение системы в рамках бизнеса.","Роль в требованиях: бизнес-правила уточняют, как система должна функционировать. Пример: \"Скидка не может превышать 50% от стоимости товара\"."]},{"l":"Методы выявления бизнес-правил","p":["Интервью с экспертами.","Анализ существующих документов и политик.","Изучение нормативных актов и стандартов."]},{"l":"Влияние бизнес-правил на различные типы требований к ПО","p":["Бизнес-правила играют ключевую роль в разработке требований к ПО, так как они формируют основу для создания функционала, ограничений и поведения системы.","Влияние бизнес-правил на типы требований:","Функциональные требования:","Бизнес-правила определяют, как должна работать система в определенных сценариях.","Пример: В интернет-магазине бизнес-правило может гласить: \"Скидка применяется только к товарам, не участвующим в других акциях\". Это определяет функциональное требование — система должна проверять, есть ли скидки на товар, перед применением другой акции.","Нефункциональные требования:","Бизнес-правила могут задавать ограничения, связанные с качественными характеристиками системы:","Пример: \"Ответ на запрос клиента должен предоставляться в течение 3 секунд\".","Пользовательские требования:","Правила влияют на сценарии взаимодействия пользователя с системой.","Пример: \"Пользователь должен вводить пароль, содержащий не менее 8 символов\".","Системные требования:","Бизнес-правила могут требовать соблюдения стандартов или взаимодействия с другими системами.","Пример: \"Система должна быть совместима с национальной системой налогообложения\"."]},{"l":"Классификация бизнес-правил. Организация хранения бизнес-правил"},{"l":"Классификация","p":["Операционные правила: Правила, определяющие действия системы. Пример: \"Пользователь должен вводить пароль длиной от 8 символов\".","Управляющие правила: Правила, которые описывают управляющие условия. Пример: \"Все транзакции должны быть одобрены менеджером\"."]},{"l":"Организация хранения","p":["Используйте базы знаний (например, Confluence).","Храните в виде правил (например, в таблицах или схемах)."]},{"l":"Статические диаграммы анализа функциональных требований","p":["Статические диаграммы используются для моделирования структурных аспектов системы, таких как классы, объекты и их взаимосвязи. Они не показывают поведение системы, а фокусируются на ее компонентах."]},{"l":"Типы статических диаграмм","p":["Диаграмма классов (Class Diagram): Показывает основные объекты системы (классы), их атрибуты, методы и связи.","Диаграмма сущность-связь (ERD, Entity-Relationship Diagram): Используется для моделирования базы данных. Показывает сущности, их атрибуты и отношения между ними.","Пакетная диаграмма (Package Diagram): Моделирует логическую организацию системы, разбивая ее на пакеты (модули)."]},{"l":"Динамические диаграммы анализа функциональных требований","p":["Динамические диаграммы показывают, как система ведет себя при выполнении задач или обработке событий. Они фокусируются на процессах и взаимодействиях."]},{"l":"Типы динамических диаграмм","p":["Диаграммы последовательности (Sequence Diagram): Показывают, как элементы системы взаимодействуют друг с другом во времени.","Диаграммы деятельности (Activity Diagram): Отображают последовательность действий или событий в процессе.","Диаграммы состояний (State Diagram): Показывают, как объект системы изменяет свое состояние в ответ на события.","Диаграммы взаимодействия (Interaction Overview Diagram): Объединяют элементы диаграмм последовательности и активности, отображая высокоуровневые процессы."]},{"l":"Характеристики идеальных требований","p":["Полнота: требования описывают весь процесс целиков","Однозначность: требования можно трактовать единым образом","Проверяемость: требования должны быть легко проверяемы","Реалистичность: требования должны быть реализуемыми в реальности"]},{"l":"Точки зрения на требования. Уровень детализации требований","p":["Точки зрения делятся на три вида:","Клиента.","Пользователя.","Разработчика.","Уровни детализации бывают двух видов:","Высокий уровень (общие цели).","Низкий уровень (технические детали)."]},{"l":"Определение требований к данным. Моделирование отношений данных","p":["Определение требований к данным описывают, как система работает с данными(хранения, валидация).","Для отображение связей между данными используется ERD."]},{"l":"Диаграммы классов. Словарь данных. Анализ данных","p":["Диаграммы классов: Показывают объекты и их атрибуты.","Словарь данных: Документирует данные (например, названия и типы полей).","Анализ данных: Проверяет корректность и полноту данных."]},{"l":"Нефункциональные требования. Классы нефункциональных требований","p":["Нефункциональные требования (НФТ)— это требования, описывающие характеристики системы, которые влияют на ее качество."]},{"l":"Основные классы НФТ","p":["Производительность:","Пример: \"Система должна обрабатывать не менее 500 запросов в секунду\".","Масштабируемость:","Пример: \"Система должна поддерживать добавление новых серверов без остановки работы\".","Надежность:","Пример: \"Система должна быть доступна 99.9% времени\".","Удобство использования (Usability):","Пример: \"Среднее время обучения пользователя не должно превышать 2 часов\".","Безопасность:","Пример: \"Пароли должны храниться в зашифрованном виде\".","Совместимость:","Пример: \"Система должна работать на Windows, macOS и Linux\"."]},{"l":"Атрибуты качества. Внешние и внутренние атрибуты качества","p":["Атрибуты качества определяют, насколько система удовлетворяет свои цели.","Внешние атрибуты качества(важны для пользователей):","Производительность.","Удобство использования.","Доступность.","Внутренние атрибуты качества(важны для разработчиков):","Простота поддержки.","Модульность.","Читаемость кода."]},{"l":"Прототипы как средство снижения риска. Классификация прототипов","p":["Прототипы— это упрощенные версии продукта, созданные для проверки концепций и снижения рисков.","Роли прототипов:","Обратная связь от клиентов.","Проверка идей и гипотез.","Оценка сложности реализации."]},{"i":"классификация-прототипов","l":"Классификация прототипов:","p":["Бумаговоры (Paper Prototypes): Ручные зарисовки интерфейсов.","Интерактивные прототипы: Создаются с использованием инструментов (Figma, Axure).","Кодовые прототипы: Простейшая версия приложения с минимальным функционалом."]},{"l":"Определение приоритетов требований. Приемы определения приоритетов","p":["Определение приоритетов позволяет сфокусироваться на самых важных задачах."]},{"l":"Методы","p":["MoSCoW: Must Have, Should Have, Could Have, Won’t Have.","Метод аналитической иерархии (AHP): Разбиение требований на уровни важности.","Модель Кано (Kano Model): Классификация функций на базовые, производящие \"вау-эффект\" и нейтральные."]},{"l":"Утверждение требований. Рецензирование требований","p":["Утверждение требований— это процесс согласования требований с клиентом и командой."]},{"i":"методы-1","l":"Методы","p":["Рецензирование: Проверка требований на полноту, точность.","Создание критериев приемки: Четкие условия, которые требования должны удовлетворять."]},{"l":"Прототипы требований. Тестирование требований","p":["Прототипы требований помогают визуализировать ожидания клиента.","Тестирование требований- проверка на соответствие ожиданиям и технической реализуемости."]},{"l":"Утверждение требований с применением критериев приемки","p":["Критерии приемки— это условия, которые требования должны удовлетворять для утверждения.","Пример:","Требование: \"Пользователь должен авторизоваться через email\".","Критерий приемки: \"Система проверяет, что введенный email существует\"."]},{"l":"Повторное использование требований. Виды и сценарии"},{"l":"Виды повторного использования","p":["Функциональные требования:","Пример: Авторизация.","Нефункциональные требования:","Пример: \"Система должна быть доступна 24/7\"."]},{"i":"сценарии","l":"Сценарии:","p":["Типовые процессы: Регистрация.","Шаблоны интерфейсов: Форма поиска."]}],[{"l":"Шпаргалка по Helm"},{"i":"что-такое-helm-и-зачем-он-нужен","l":"Что такое Helm и зачем он нужен?","p":["Helm- менеджер пакетов для Kubernetes, который позволяет:","Описывать приложения и их конфигурации в виде charts.","Устанавливать и управлять приложениями с помощью командной строки.","Упрощать обновление, удаление и версионирование приложений."]},{"i":"что-такое-helm-chart","l":"Что такое Helm Chart?","p":["Chart- набор файлов, описывающих Kubernetes-приложение. Он включает:","Шаблоны манифестов","Файлы конфигурации","Метаинформацию","Пример структуры:"]},{"i":"как-создать-helm-chart","l":"Как создать Helm Chart?"},{"i":"как-установить-приложение-с-помощью-helm","l":"Как установить приложение с помощью Helm?"},{"i":"что-такое-release","l":"Что такое Release?","p":["Release- установленная версия chart'а в кластере. Имя релиза позволяет управлять установленным приложением."]},{"i":"как-просмотретьт-установленные-releases","l":"Как просмотретьт установленные Releases?"},{"i":"как-удалить-release","l":"Как удалить Release?"},{"i":"что-такое-values","l":"Что такое Values?","p":["Values- настройки, которые влияют на генерацию манифестов. Они хранятся в values.yaml и могут быть переопределены при установке.","Способ через переопределение значений:"]},{"i":"как-работают-шаблоны-в-helm","l":"Как работают шаблоны в Helm?","p":["Шаблоны пишутся на языке Go Templates и используют директивы."]},{"i":"как-проверить-сгенерированные-манифесты","l":"Как проверить сгенерированные манифесты?"},{"i":"как-обновить-release","l":"Как обновить Release?"},{"i":"что-такое-helm-repository","l":"Что такое Helm Repository?","p":["Helm Repository- хранилище Helm Chart'ов.","Для работы с репозиториями есть команды.","Пример:"]},{"i":"что-такое-helm-hooks","l":"Что такое Helm Hooks?","p":["Helm Hooks- специальные шаблоны, которые выполняются на разных этапах жизненного цикла."]},{"i":"как-протестировать-helm-chart","l":"Как протестировать Helm Chart?"},{"i":"как-откатить-изменения","l":"Как откатить изменения?"},{"i":"как-работают-зависимости-в-helm","l":"Как работают зависимости в Helm?"},{"i":"что-такое-helm-secrets","l":"Что такое Helm Secrets?","p":["Для безопасного хранения секретов можно использовать плагин Helm Secrets, который шифрует файлы через SOPS."]},{"i":"как-настроить-cicd-в-helm","l":"Как настроить CI/CD в Helm?"},{"l":"Полезные команды Helm"}],[{"l":"Шпаргалка по Kubernetes"},{"i":"что-такое-kubernetes","l":"Что такое Kubernetes?","p":["Kubernetes- инфраструктурная платформа, содержащая в себе фреймворк для декларативного управления конфигурациями приложений на основе контейнеризации и виртуализации. Она является де-факто стандартом для оркестрации контейнеров, предоставляя богатый функционал для управления инфраструктурой, сетями, хранением данных и приложениями."]},{"i":"что-такое-pod","l":"Что такое POD?","p":["Pod- минимальная единица развертывания в Kubernetes, которая предоставляет собой группу контейнеров, объединенных общей сетью(общий localhost, общий внешний IP) и общими ресурсами. Контейнеры внутри POD работают в тесной связке."]},{"i":"для-чего-при-старте-podа-создается-контейнер-с-процессом-pause","l":"Для чего при старте PODа создается контейнер с процессом pause?","p":["Для того чтобы создать сетевую изоляцию Kubernetes при старте POD'а запускает специальный контейнер pause. Он отвечает за управление сетью и обеспечивает контейнерам внутри POD'а возможность взаимодействовать через localhost. Он не выполняет реальную работу, а является посредником при сетевом взаимодействии."]},{"i":"как-можно-запускать-поды","l":"Как можно запускать поды?","p":["POD'ы обычно запускаются с помощью workloads, которые обеспечивают управление жизненным циклом POD'ов.","Примеры:","(ReplicationController) Deployment- для развертывания и управления репликами POD'ов с возможность откатов.","StatefulSet- для приложений с состоянием, которые требуют уникальности и постоянства идентификаторов.","DaemonSet- для запуска одного POD'а на каждом узле кластера.","Job- для запуска одноразовых задач.","CronJob- для запуска задач по расписанию."]},{"i":"в-чем-разница-между-deployment-и-statefulset","l":"В чем разница между Deployment и StatefulSet?","p":["В именах: у первого некий случайный хэш, у второго - порядковый номер.","В работе с дисками: StatefulSet дожидается пока POD с таким же именем завершит работы, чтобы занять тот диск, который был к нему привязан.","В стратегиях перезапуска POD'ов при обновлении."]},{"i":"что-такое-replicaset","l":"Что такое ReplicaSet?","p":["ReplicaSet- это объект, который управляет количеством реплик POD'ов в Kubernetes. ReplicaSet гарантирует, что в любой момент времени будет существовать определенное количество копий POD'ов. В Kubernetes обычно используют Deployment, который управляет ReplicaSet."]},{"i":"что-такое-kubernetes-probes","l":"Что такое Kubernetes probes?","p":["Проверки состояния контейнера - механизмы для мониторинга состояния приложений и контейнеров.","Kubernetes поддерживает три вида проверок:","Startup probe- проверка, которая используется для определения, когда контейнер полностью инициализировался. Если эта проверка не проходит, другие пробы не выполняются.","Readiness probe- проверка готовности контейнера к обслуживанию трафика. Если она не проходит, контейнер не будет получать трафик.","Liveness probe- проверка живости контейнера. Если она не проходит, контейнер перезапускается."]},{"i":"какие-хорошие-практики-существуют-при-создании-проб","l":"Какие хорошие практики существуют при создании проб?","p":["Пробы должны проверять рабочие и критические компоненты приложения, чтобы гарантировать, что приложение может обрабатывать запросы пользователя.","Пробы не должны быть слишком частыми или тяжелыми, чтобы не создавать дополнительную нагрузку на систему.","Пробы не должны зависеть от внешних сервисов, если только это не критично для работы приложения.","Используйте сквозные проверки, если приложение имеет несколько взаимосвязанных сервисов."]},{"i":"что-такое-pod-disruption-budget","l":"Что такое Pod Disruption Budget?","p":["Pod Disruption Budget (PDB)- механизм, который гарантирует, что в кластере всегда будет доступно минимальное количество POD'ов для определенного приложения. PDB помогает предотвратить слишком большое количество перерывов в работе приложения при обслуживании или удалении POD'ов."]},{"i":"что-такое-priority-classes","l":"Что такое priority classes?","p":["Priority Classes- механизм, который позволяет назначать приоритеты POD'ам, чтобы Kubernetes мог управлять распределением ресурсов между POD'ами с разными приоритетами, особеннос в случае нехватки ресурсов."]},{"i":"что-такое-pod-eviction","l":"Что такое POD eviction?","p":["Eviction- процесс удаления POD'ов с узлов, когда ресурсы на узле становятся дефицитными(нехватки памяти или диска). Kubernetes может эвакуировать POD'ы с низким приоритетом, чтобы освободить ресурсы для более важных приложений."]},{"i":"каким-образом-можно-управлять-размещением-podов-на-конкретных-нодах-кластера-k8s","l":"Каким образом можно управлять размещением PODов на конкретных нодах кластера k8s?","p":["NodeSelector/Node Affinity- позволяет указать, на каких узлах можно запускать POD'ы, основываясь на метках нод.","Taints/Tolerations- механизм, который запрещает или разрешает запуск POD'ов на определенных узлах в зависимости от их меток.","Pod Affinity/Anti-Affinity- механизм, позволяющий задавать правила для размещения POD'ов на одних или разных узлах в зависимости от меток."]},{"i":"каким-образом-можно-управлять-вычислительными-ресурсами-в-k8s","l":"Каким образом можно управлять вычислительными ресурсами в k8s?","p":["Resources requests и limits позволяют управлять количеством ресурсов, которое контейнер может использовать.","Request- минимальное количество ресурсов, которое контейнер гарантировано получит.","Limits- максимальное количество ресурсов, которое контейнер может использовать."]},{"i":"что-такое-kubernetes-service","l":"Что такое Kubernetes service?","p":["Service- абстракция, которая позволяет организовывать доступ к приложениям, работающим в Kubernetes, через постоянный IP-адрес или DNS-имя. Сервис может выполнять балансировку трафика между POD'ами."]},{"i":"каким-образом-можно-предоставить-приложение-которые-работает-в-кластере-пользователям","l":"Каким образом можно предоставить приложение, которые работает в кластере, пользователям?","p":["Если приложение работает по HTTP, то можно использовать Ingress-контроллер. Ingress позволяет маршрутизировать HTTP/HTTPS-трафик от пользователей к приложениям в кластере.","Если приложение работает по бинарному протоколу(PostgreSQL), то обычно используют Service с типом NodePort или LoadBalancer, чтобы сделать его доступным извне."]},{"i":"почему-ingress-удобен","l":"Почему Ingress удобен?","p":["Используя Ingress, можно управлять маршрутизацией трафика для всех приложений внутри кластера через одну точку входа. Это позволяет эффективно управлять HTTP/HTTPS-трафиком, используя такие функции как:","Балансировка нагрузки","Поддержка HTTPS","Маршрутизация по поддоменам или URL","Поддержка канареечных развертываний"]},{"i":"каким-образом-организована-сеть-в-k8s","l":"Каким образом организована сеть в k8s?","p":["В Kubernetes существует три типа сети:","Node Network- сеть, в которую объединены ноды. В зависимости от использования CNI-плагина, ноды могут работать только в одной подсети, либо в нескольких.","Pod Network- сеть, в которой получают IP-адреса запускаемые PODы.","Service Network- сеть, в которой получают адреса Kubernetes services.","Pod network и service network орнанизуются при помощи так называемых CNI-плагинов."]},{"i":"что-такое-cni-плагин-и-для-чего-он-нужен","l":"Что такое CNI-плагин и для чего он нужен?","p":["CNI расшифровывается как Container Network Interface. Он представляет собой некий уровень абстракции над реализацией сети. Мы может работать с верхнеуровневыми абстракциями вроде \"IP-адрес POD'а\", Endpoint. За то как это будет реализовано на физическом уровне отвечают CNI-плагины, которые реализуют разный функционал и показывают разную сетевую производительность.","Примеры CNI-плагинов:","Flannel","Calico","Cilium"]},{"i":"что-такое-egress","l":"Что такое EGRESS?","p":["EGRESS- возможность назначить внешний IP-адрес для исходящего за пределы кластера k8s трафика приложений. Поддержка EGRESS должна быть реализована на уровне CNI-плагина и может быть описана специальным объектом на уровне неймспейса."]},{"i":"как-мы-можем-ограничить-трафик-в-kubernetes","l":"Как мы можем ограничить трафик в Kubernetes?","p":["Для ограничения трафика от приложений используется объект NetworkPolicy. При помощи него мы можем ограничивать входящий и исходящий трафик на уровне неймспейса и компонентов, описанных в нем. Его поддержка должна быть реализована на уровне CNI-плагина."]},{"i":"что-такое-service-mesh-и-для-чего-он-нужен","l":"Что такое Service Mesh и для чего он нужен?","p":["Service Mesh- паттерн, позволяющий более гибко управлять трафиком в Kubernetes. Servise Mesh состоит из:","control plane, который собирает информацию о кластере k8s","запущенных в нем приложениях","дополнительных объектов, которые могут быть описаны для дополнительной конфигурации","sidecar-контейнеров, которые инжектятся в POD'ы автоматически при помощи mutation webhook.","Sidecar-контейнеры- reverse-прокси, перехватывающие входящий и исходящий трафик приложений в контейнерах и управляющие им в зависимости от полученной из control plane конфигурации.","Основные задачи для Service Mesh:","Гарантий доставки трафика до приложений(retry, timeouts, circuit breaker)","Увеличение безопасности при помощи шифрования трафика, верификации трафика на основе сертификатов, реализация дополнительных правил и разрешений на передачу трафика","Реализация переключения трафика при canary, a/b, blue/green стратегий деплоя.","Недостатки:","Избыточная сложность","Повышенная ресурсоемкость","Накладные расходы"]},{"i":"в-чем-отличие-меток-от-аннотаций","l":"В чем отличие меток от аннотаций?","p":["Метки используются для реализации механизмов поиска и группировки объектов. Аннотации используются для описания метаинформации на объекте."]},{"i":"из-каких-компонентов-состоит-k8s-и-каково-их-назначение","l":"Из каких компонентов состоит k8s и каково их назначение?","p":["Kubernetes состоит из control plane и data plane.","Control Plane- управляющий контур, который запускается в пределах нод, называемых master, и может запускаться как одиночном режиме( single master), так и в распределенном( multi master).","Control plane содержит:","ETCD- хранилище конфигурации кластера","Kubernetes API- предоставляет API, посредством которого взаимодействуют компоненты k8s, а также клиенты находящиеся внутри и вне кластера.","Kubernetes Controller Manager- реализует концепцию контроллеров, которые управляют базовыми сущностями кластеров.","Kubernetes scheduler- выбирает ноды, на которых нужно запускать PODы.","Cloud controller manager- используется для реализации функций работы с облаком.","Data plane- компоненты, которые запущены на каждой ноде.","kubelet- следит за изменениями конфигурации ноды, применяет конфигурации, делает пробы контейнеров, отчитывается о статусе контейнеров, работает с CRI-плагином и реализует функции запуска и остановки контейнеров.","kube-proxy- отвечает за сетевой компонент. Работает с CNI-плагином и обеспечивает функционрирование сущности Service в пределах своей ноды."]},{"i":"что-такое-kube-proxy-и-для-чего-он-нужен","l":"Что такое kube-proxy и для чего он нужен?","p":["kube-proxy- компонент data plane, который работает на каждой ноде. Он взаимодействеут с CNI-плагином, обеспечивая функционирование pod network. А также обеспечивает функционирование описанных в кластере сервисов в пределах своей ноды. В зависимости от режима выступает либо в роли прокси, либо как контроллер правил IPTABLES/IPVS."]},{"i":"что-такое-cri","l":"Что такое CRI?","p":["CRI расшифровыется как Container Runtime Interface. Это спецификация, описывающая некий уровень абстракции, который позволяет унифицированно использовать разные версии ПО для работы с контейнерами, например containerd или CRI-O."]},{"i":"какие-типы-volumов-можно-использовать-в-kubernetes","l":"Какие типы volum'ов можно использовать в Kubernetes?","p":["hostpath, но тогда POD должен быть привязан к ноде.","local-storage - автоматически привязывает POD, который его использует, к нужной ноже.","Также можно использовать сетевые диски при помощи CSI-плагинов."]},{"i":"что-такое-csi-плагин","l":"Что такое CSI-плагин?","p":["CSI расшифровывается как Container Storage Interface. Это абстракция, позволяющая унифицированно использовать сетевые файловые системы, построенные на разных технологических базах.","Мы описываем storageClass, соответствующий дискам определенного типа, и деплоим в кластер provisioner.","Provisioner- специальное ПО, которое может заказывать сетевые диски в системе, способной их предоставлять.","Далее мы описываем объект persistentVolumeClaim с указанием нужного storageClass.","Provisioner при появлении PVC заказывает диск нужного размера в системе, которая их предоставляет, создает объект persistentVolume и привязывает его к PVC. Когда происходит запуск POD'а на ноде, соотвествующий диск монтируется на нужную ноду по определенному пути, и этот путь монтируется на файловую систему PODа."]},{"i":"каким-образом-мы-можем-разделить-права-на-kubernetes","l":"Каким образом мы можем разделить права на Kubernetes?","p":["Для разделения прав в Kubernetes применяется механизм Role Based Access Control(RBAC). В рамках него есть три группы сущностей:","user или service account- который описывает субъект доступа.","role или cluster role- который описывает разрешения.","roleBinding или clusterRoleBinding- который привязывает списки разрешений к субъекту."]},{"i":"в-чем-отличие-service-account-от-user","l":"В чем отличие service account от user?","p":["User не имеет записей в Kubernetes API, управление осуществляется внешними механизмами. Они предназначены для событий вне кластера."]},{"i":"какие-механизмы-аутентификации-используются-в-kubernetes","l":"Какие механизмы аутентификации используются в Kubernetes?","p":["Kubernetes может использовать:","сертификаты X509","Bearer-токены","аутентифицирующий прокси","HTTP Basic Auth","При помощи этих механизмов можно реализовывать большое количество схем авторизации: от статичного файла с паролями до OpenID OAuth2.","Более того, допускается применение нескольких схем авторизации одновременно. По умолчанию используются:","service account tokens - для Service Accounts","X509 - для Users"]},{"i":"что-такое-namespace-в-k8s-и-для-чего-он-нужен","l":"Что такое namespace в k8s и для чего он нужен?","p":["Участвует в формировании DNS-имен внутри кластера. [service name].[namespace].[суффикс кластера].","Суффикс по-умолчанию: svc.cluster.local."]},{"i":"что-такое-финалайзеры-и-для-чего-они-нужны","l":"Что такое финалайзеры и для чего они нужны?","p":["Это специальные ключи в манифесте объекта, описывающие действия, которые требуется совершить до удаления обзъекта."]}],[{"l":"Шпаргалка по базам данных"},{"l":"Установка PSQL"},{"l":"Нормализация","p":["Нормализация- процесс преобразования структуры БД для уменьшения избыточности данных и предотвращения аномалий обновления. Она основана на математической теории реляционных баз данных."]},{"l":"Первая нормальная форма","p":["У таблицы должна быть первичная ключевая колонка(ID,UUID).","Все строки таблицы уникальны.","Все значения атрибутов(столбцов) должны быть атомарными(неделимыми).","До 1NF:","Фирма","Модели","BMW","M5,X5M,M1","Nissan","GT-R","После 1NF:","M5","X5M","M1"]},{"l":"Вторая нормальная форма","p":["10%","2500000","5%","5000000","5500000","6000000","BMW","GT-R","M1","M5","Nissan","X5M","Все неключевые атрибуты должны зависить от всего составного ключа, а не от его части.","До 2NF:","Модель","После 2NF: Цена зависит от модели и фирмы, а скидка зависит только от фирмы","Скидка","Таблица находится в 1НФ.","Фирма","Цена"]},{"l":"Третья нормальная форма","p":["Таблица находится в 2НФ.","Все неключевые атрибуты должны зависеть только от первичного ключа.","До 3NF:","Модель","Магазин","Телефон","BMW","Риал-авто","87-33-98","Audi","Nissan","Некст-Авто","94-54-12","После 3NF: Телефон не зависит от первичного ключа, а от магазина."]},{"l":"Нормальная форма Бойса-Кодда или Частная форма 3NF","p":["09:30","1","10:00","10:30","11:00","12:00","14:00","15:00","15:30","18:00","2","Cтандарт","Бережливый","Время начала","Время окончания","Все неключевые атрибуты не должны зависеть от других неключевых.","До BCNF:","Номер стоянки","После BCNF: Номер стоянки зависит от тарифа, а также время окончания зависит от времени начала и тарифа","Премиум-А","Премиум-В","Таблица в 3NF.","Тариф"]},{"l":"Четвертая нормальная форма","p":["1","2","3","FabioRoss","ID","Все многозначные зависимости должны быть удалены. То есть атрибуты зависят от первичного ключа, но не от друг друга.","Гитара","До 4NF:","Доска Почета","КайзерДом","После 4NF: Проект и хобби зависят от ID, но не от друг друга. Это многозначная зависимость","Проект","Радиотехника","Сантехник","Таблица в BCNF:","Футфол","Хобби","Хоккей"]},{"l":"Пятая нормальная форма","p":["Таблица в 4NF.","Отсутствуют сложные зависимости между атрибутами.","Правило, которое крайне трудно найти на практике в чистом виде.","До 5NF:","Производитель","Продукт","Поставщик","A","Продукт1","X","Продукт2","B","Y","После 5NF: Присутствует трехсторонняя зависимость"]},{"l":"Шестая нормальная форма","p":["Та форма когда отношение уже неможет быть декомпозирована без потерь."]},{"i":"диаграммы-сущность-связь-или-er-диаграммы","l":"Диаграммы \"сущность-связь\" или ER-диаграммы","p":["ER-диаграммы используются для визуализации структуры БД на этапе проектирования."]},{"l":"Основные элементы ER-диаграммы","p":["Сущность: объекты, которые надо хранить в БД.","Атрибуты: свойства сущностей.","Связи: отношения между сущностями."]},{"l":"Уровни ER-диаграммы","p":["Концептуальный уровень: отображает только основные сущности и связи.","Логический уровень: добавляет атрибуты и детали связей","Физический уровень: конкретизация хранения, включая ключи и индексы."]},{"l":"Методы разработки ER-диаграмм","p":["Определение сущностей- выявление объектов, о которых нужно хранить данные.","Определение атрибутов- свойства сущностей.","Определение связей между сущностями- устанавливается, как объекты взаимодействуют друг с другом.","Создание диаграммы- используются специальные символы для сущностей, атрибутов и связей."]},{"l":"Средства разработки ER-диаграмм","p":["Ручное рисование","Специализированные инструменты: Lucidchart,Draw.io,Microsoft Visio,MySQL Workbench."]},{"l":"Ограничения","p":["Кардинальность: определяет количество записей, связанных друг с другом(1:1, 1:N, M:N).","Обящательность: показывает, может ли существовать без определенной сущность."]},{"l":"Структура языка SQL","p":["SQL- тьюринго-полные язык программирования, нацеленный на создания запросов к БД. Состоит из нескольких DSL(Domain Specific Language): DDL, DML, DQL, TCL, DCL."]},{"i":"ddl---data-definition-language","l":"DDL - Data Definition Language","p":["DDL- используется для определения структуры базы данных.","CREATE TABLE","ALTER TABLE","DROP TABLE"]},{"i":"dml---data-manipulation-language","l":"DML - Data Manipulation Language","p":["DML- используется для управления данными.","INSERT INTO","UPDATE","DELETE"]},{"i":"dql---data-query-language","l":"DQL - Data Query Language","p":["DQL- используется для извлечения данных. Основная команда SELECT.","Пример:"]},{"i":"tcl---transaction-control-language","l":"TCL - Transaction Control Language","p":["TCL- используется для управления транзакциями.","COMMIT- подтверждение.","ROLLBACK- откат изменений.","SAVEPOINT- создание точки отката."]},{"i":"dcl---data-control-language","l":"DCL - Data Control Language","p":["DCL- используется для управления правами доступа.","GRANT- предоставление прав.","REVOKE- отзык прав."]},{"l":"Типы данных SQL","p":["Типы данных определяют, какие значения можно хранить в колонке таблицы."]},{"l":"Числовые","p":["INT, SMALLINT, BIGINT- целые числа разной разрядности.","DECIMAL(p,s), NUMERIC(p,s)- числа с фиксированной точностью.","FLOAT,REAL- числа с плавающей точкой."]},{"l":"Строковые","p":["CHAR(n)- строка фиксированной длины.","VARCHAR(n)- строка переменной длины.","TEXT- текстовые данные большой длины."]},{"l":"Дата и время","p":["DATE- только дата.","TIME- только время.","TIMESTAMP- дата и время."]},{"l":"Булевы","p":["BOOLEAN- значения TRUE,FALSE"]},{"l":"Операторы SQL"},{"l":"Структура SQL-операторов","p":["Операторы SQL структурированы по их назначения: DDL, DML, DQL, TCL, DCL. Смотреть выше."]},{"l":"Нотации SQL","p":["Стандартная нотация- поддерживается всеми СУБД.","Расширенная нотация- поддерживается только конкретной СУБД."]},{"l":"Форматы конструкций","p":["DDL:","DML:","DQL:","TCL:","DCL:"]},{"l":"Извлечение данных с использоывним SQL","p":["Как было сказано выше, извлечение данных осуществляется с помощью команды SELECT.","Ключевые конструкции:","WHERE: фильтрация данных.","ORDER BY: сортировка данных.","GROUP BY: группировка данных.","LIMIT: ограничение количества возвращаемых строк."]},{"l":"Обобщение данных с помощью агрегатных данных","p":["Агрегатные функции позволяют обобщать данные.","Основные функции:","COUNT: количество строк.","SUM: сумма значений.","AVG: среднее значение.","MAX и MIN: максимальное и минимальное значения."]},{"i":"многотабличные-запросы-подзапросы","l":"Многотабличные запросы, подзапросы","p":["Для объединения данных из нескольких таблиц используют JOIN."]},{"i":"соединения-теоретико-множественные-и-специальные-операции-над-отношениями","l":"Соединения, теоретико-множественные и специальные операции над отношениями","p":["Соединения:","INNER JOIN: только совпадающие строки.","LEFT JOIN: все строки из левой таблицы + совпадения.","RIGHT JOIN: все строки из правой таблицы + совпадения.","FULL JOIN: все строки из обоих таблиц.","Теоретико-множественные операции:","UNION: объединение.","INTERSECT: пересечение.","EXCEPT: разность.","Специальные операции:","CROSS JOIN: возвращает все комбинации строк из двух таблиц.","SELF JOIN: используется для сопоставления строк в одной таблице."]},{"l":"Группирование результатов запроса","p":["Используется для логической группировки строк."]},{"l":"Использованеи предложения UNION","p":["Объединяет результаты двух или более запросов. Дублирующиеся строки исключаются.","Используйте UNION ALL, если нужны дублирующиеся строки."]},{"l":"Основные объекты языка SQL"},{"l":"Таблицы","p":["Таблицы- основные структуры для хранения данных."]},{"l":"Представления","p":["Представления- логические таблицы, основанные на результатах запросов, или виртуальные таблицы, содержимое которых определяется запросом. Они позволяют:","Упрощать сложные запросы.","Повышать безопасность, скрывая часть данных.","Улучшать читаемость запросов."]},{"l":"Хранимые процедуры и функции","p":["Хранимые процедуры и функции- программные блоки, хранящиеся и выполняемые на сервере базы данных. Они позволяют:","Повысить производительность за счет выполнения на сервере.","Уменьшить передачу данных между клиентом и сервером.","Повторно использовать код."]},{"l":"Триггеры","p":["Триггеры- код, который автоматически запускается при определенных событиях в таблице."]},{"l":"Индексы","p":["Индексы- структуру для ускорения поиска данных. Они создают структуру данных, основанную на значениях одной или нескольких колонок таблицы.","Кластерный индекс- физически упорядочивает строки таблицы в соответствии со значением индекса.","Некластерный индекс- создает отдельную структуру, ссылающуюся на данные таблицы.","Уникальный индекс- гарантирует уникальность значений."]},{"l":"Правила и стратегии поддерживания целостности данных","p":["Целостность данных- обеспечивает корректность и согласованность данных в базе.","Основные правила которые надо соблюдать:","Добавлять первичный ключ, он уникально идентифицирует каждую запись.","Добавлять внешние ключи, они обеспечивают связь между таблицами.","Добавлять NOT NULL, запрещает хранение пустых значений.","Добавлять CHECK, накладывает ограничения на значения.","Стретегии:","Каскадное обновление и удаление: ON DELETE CASCADE ON UPDATE CASCADE"]},{"l":"Методы совместного доступа к базам данных","p":["Совместный доступ необходим, когда несколько пользователей работают с одной базой данных.","Параллелизм- выполнение нескольких операций одновременно.","Конкуренция- несколько транзакций обращаются к одним и тем же данным.","Типы параллелизма:","Данные распределяются: каждый запрос обрабатывает разные данные.","Функциональный параллелизм: каждая транзакция выполняет разные функции.","Механизмы совместного доступа:","Блокировки","Управление версиями данных"]},{"l":"Транзакции и блокировки"},{"l":"Транзакции","p":["Транзакция- последовательность операций, которая выполняется как единое целое.","Свойства транзакции:","Атомарность: либо все операции выполняются, либо ни одна.","Согласованность: после завершения данные остаются в корректном состоянии.","Изолированность: параллельные транзакции ни влияют друг на друга.","Долговечность: данные сохраняются даже после сбоя системы.","Если транзакция не может быть завершена, используют ROLLBACK."]},{"l":"Блокировки","p":["EXCLUSIVE(исключительная): транзакция блокирует запись всех операций.","SHARED(разделяемая): несколько транзакций могут читать одну и ту же запись."]},{"l":"Уровни изолированности пользователей","p":["READ UNCOMMITTED: транзакции видят незавершенные изменения других транзакций.","READ COMMITED: транзакции видят только завершенные изменения.","REPEATABLE READ: запросы видят одно и то же состояние данных в пределах транзакции.","SERIALIZABLE: полная изолированность. Максимальная защита от конфликтов."]},{"l":"Параллельное выполнение транзакций","p":["Чтобы избежать конфликтов, применяются:","Блокировки","Уровни изолированности."]},{"l":"Методы сериализации транзакций","p":["Сериализация- порядок выполнения транзакций, обеспечивающих корректность данных.","Методы:","Протокол блокировок 2-фазного типа: фаза1 - транзакция получает блокировки, фаза2 - транзакуия снимает блокировки.","Графы предшествования: определяет порядок транзакций, чтобы избежать конфликтов."]},{"l":"Проблема тупиковых ситуаций и ее решение","p":["Тупик(Deadlock)- ситуация, которая возникает если две или более транзакции ожидают освобождения ресурсов друг другом.","Решение:","Построение графа ожидания. Если есть цикл, то это тупик.","Назначение тайм-аута для транкзакций.","Определение приоритетов транзакций."]},{"l":"Синхронизационные захваты","p":["Синхронизация- позволяет нескольким пользователям работать с базой одновременно без ошибок.","Механизмы:","Семафоры: ограничивают количество одновременно выполняемых операций.","Мьютексы: предотвращают одновременное выполнение критических операций."]},{"l":"Распределенные базы данных","p":["Распределенные базы данных- системы, в которых данные хранятся на нескольких серверах, расположенных в разных местах, и управляются как единое целое.","Задачи распределенных баз данных:","Распределение данных","Управление распределением","Оптимизация запросов","Проблемы распределенных баз данных:","Сеть: низкая скорость или разрывы соединения влияют на доступ к данным.","Целостность: сложность обеспечения согласованности между серверами.","Управление транзакциями: необходимость глобального контроля транзакций."]},{"l":"NoSQL","p":["NoSQL- это тип СУБД, ориентированных на обработку больших объемов данных и высокую масштабируемость.","Особенности:","Нерялиционная модель","Свободная схема","Простой API","Распределенность"]},{"l":"Типы баз данных","p":["Ключ-значения","Документоориентированные","Графовые базы данных","Колоночные базы данных"]},{"l":"Практические задачи"},{"i":"как-создавать-таблицы","l":"Как создавать таблицы?","p":["id INT AUTO_INCREMENT PRIMARY KEY для первичного ключа","Отношения","Везде где надо добавляйте NOT NULL."]},{"i":"запросыпримеры","l":"Запросы(примеры)"}]]